slip_1

#include<stdio.h>
#define MAX 20
int frames[MAX],ref[MAX],mem[MAX][MAX],faults, 
 sp,m,n,count[MAX]; 
void accept() 
{ 
int i; 
printf("Enter no.of frames:"); 
scanf("%d", &n); 
printf("Enter no.of references:"); 
scanf("%d", &m); 
printf("Enter reference string:\n"); 
for(i=0;i<m;i++) 
 { 
 printf("[%d]=",i); 
 scanf("%d",&ref[i]); 
 } 
} 
void disp() 
{ 
int i,j; 
for(i=0;i<m;i++) 
 printf("%3d",ref[i]); 
printf("\n\n"); 
for(i=0;i<n;i++)
 { 
 for(j=0;j<m;j++) 
 { 
 if(mem[i][j]) 
 printf("%3d",mem[i][j]); 
 else
 printf(" "); 
 } 
 printf("\n"); 
 } 
printf("Total Page Faults: %d\n",faults); 
} 
int search(int pno) 
{ 
int i; 
for(i=0;i<n;i++) 
 { 
 if(frames[i]==pno) 
 return i; 
 } 
return -1; 
} 
int get_lfu(int sp) 
{ 
int i,min_i,min=9999; 
 i=sp; 
do
 { 
 if(count[i]<min) 
 { 
 min = count[i]; 
 min_i = i; 
 } 
 i=(i+1)%n; 
 }while(i!=sp); 
return min_i; 
} 
void lfu() 
{ 
int i,j,k; 
for(i=0;i<m && sp<n;i++) 
 { 
 k=search(ref[i]); 
 if(k==-1) 
 { 
frames[sp]=ref[i]; 
 count[sp]++; 
 faults++; 
 sp++; 
 for(j=0;j<n;j++) 
 mem[j][i]=frames[j]; 
 } 
 else
 count[k]++; 
 
 } 
 sp=0; 
for(;i<m;i++) 
 { 
 k = search(ref[i]); 
 if(k==-1) 
 { 
 sp = get_lfu(sp); 
 frames[sp] = ref[i]; 
 count[sp]=1; 
 faults++; 
 sp = (sp+1)%n; 
 for(j=0;j<n;j++) 
 mem[j][i] = frames[j]; 
 } 
 else
 count[k]++; 
 } 
} 
 
int main() 
{ 
accept(); 
lfu(); 
disp(); 
return 0; 
}

slip1_2

#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <unistd.h>
int make_toks(char *s, char *tok[]) {
int i = 0;
char *p;
p = strtok(s, " ");
while(p != NULL) {
tok[i++] = p;
p = strtok(NULL, " ");
}
tok[i] = NULL;
return i;
}
void typeline(char *op, char *fn) {
int fh,
i,
j,
n;
char c;
fh = open(fn, O_RDONLY);
if(fh == -1) {
printf("File %s not found.\n", fn);
return;
}
if(strcmp(op, "a") == 0) {
while(read(fh, &c, 1) > 0)
printf("%c", c);
close(fh);
return;
}
n = atoi(op);
if(n > 0) {
i = 0;
while(read(fh, &c, 1) > 0) {
printf("%c", c);
if(c == '\n') i++;
if(i == n) break;
}
}
if(n < 0) {
i = 0;
while(read(fh, &c, 1) > 0) {
if(c == '\n') i++;
}
lseek(fh, 0, SEEK_SET);
j = 0;
while(read(fh, &c, 1) > 0) {
if(c == '\n') j++;
if(j == i+n+1) break;
}
while(read(fh, &c, 1) > 0) {
printf("%c", c);
}
}
close(fh);
}
int main() {
char buff[80],
*args[10];
while(1) {
printf ("\n");
printf("\nmyshell$ ");
fgets(buff, 80, stdin);
buff[strlen(buff)-1] = '\0';
int n = make_toks(buff, args);
switch (n) {
case 1:
if(strcmp(args[0], "exit") == 0)
exit(1);
if (!fork())
execlp (args [0], args[0], NULL);
break;
case 2:
if (!fork ())
execlp (args [0], args[0], args[1], NULL);
break;
case 3:
if (strcmp(args[0], "typeline") == 0)
typeline (args[1], args[2]);
else {
if (!fork ())
execlp (args [0], args[0], args[1], args[2], NULL);
}
break;
case 4:
if (!fork ())
execlp (args [0], args [0], args [1], args [2], args [3], NULL);
break;
}
}
return 0;
}
o/p:
create text file after compile for text file type vim text.txt insert data in text file press esc
:wq now run your program using ./a.out
myshell$ typeline a text.txt
pune
kolkata
doremon
mumbai
vadapav
chandigarh
pune
prisonbreak
pogo
misalpav
gogo
pune
\0
myshell$ typeline 3 text.txt
pune
kolkata
doremon
myshell$ typeline -5 text.txt
pogo
misalpav
gogo
pune
--------------------------------------------------------------------------------------------------------

slip_no 2

2a,9,10 fifo

#include<stdio.h>
#define MAX 20
int frames[MAX],ref[MAX],mem[MAX][MAX],faults,sp,m,n;
void accept()
{
int i;
printf("Enter no.of frames:");
scanf("%d", &n);
printf("Enter no.of references:");
scanf("%d", &m);
printf("Enter reference string:\n");
for(i=0;i<m;i++)
{
printf("[%d]=",i);
scanf("%d",&ref[i]);
}
}
void disp()
{
int i,j;
for(i=0;i<m;i++)
printf("%3d",ref[i]);
printf("\n\n");
for(i=0;i<n;i++)
{
for(j=0;j<m;j++)
{
if(mem[i][j])
printf("%3d",mem[i][j]);
else
printf(" ");
}
printf("\n");
}
printf("Total Page Faults: %d\n",faults);
}
int search(int pno)
{
int i;
for(i=0;i<n;i++)
{
if(frames[i]==pno)
return i;
}
return -1;
}
void fifo()
{
int i,j;
for(i=0;i<m;i++)
{
if(search(ref[i])==-1)
{
frames[sp] = ref[i];
sp = (sp+1)%n;
faults++;
for(j=0;j<n;j++)
mem[j][i] = frames[j];
}
}
}
int main()
{
accept();
fifo();
disp();
return 0;
}
Output:
Enter no.of frames:3
Enter no.of references:16
Enter reference string:
[0]=12
[1]=15
[2]=12
[3]=18
[4]=6
[5]=8
[6]=11
[7]=12
[8]=19
[9]=12
[10]=6
[11]=8
[12]=12
[13]=15
[14]=19
[15]=8
12 15 12 18 6 8 11 12 19 12 6 8 12 15 19 8
12 12 12 6 6 6 12 12 12 8 8 8 19 19
15 15 15 8 8 8 19 19 19 12 12 12 8
18 18 18 11 11 11 6 6 6 15 15 15
Total Page Faults: 14

2b,10,11,12,15,19 search dir 

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
void make_toks(char *s, char *tok[])
{
int i=0;
char *p;
p = strtok(s," ");
while(p!=NULL)
{
tok[i++]=p;
p=strtok(NULL," ");
}
tok[i]=NULL;
}
void list(char *dn, char op)
{
DIR *dp;
struct dirent *entry;
int dc=0,fc=0;
dp = opendir(dn);
if(dp==NULL)
{
printf("Dir %s not found.\n",dn);
return;
}
switch(op)
{
case 'f':
while(entry=readdir(dp))
{
if(entry->d_type==DT_REG)
printf("%s\n",entry->d_name);
}
break;
case 'n':
while(entry=readdir(dp))
{
if(entry->d_type==DT_DIR)
dc++;
if(entry->d_type==DT_REG)
fc++;
}
printf("%d Dir(s)\t%d File(s)\n",dc,fc);
break;
case 'i':
while(entry=readdir(dp))
{
if(entry->d_type==DT_REG)
printf("%s\t%d\n",entry->d_name,entry->d_fileno);
}
}
closedir(dp);
}
int main()
{
char buff[80],*args[10];
int pid;
while(1)
{
printf("\nmyshell$");
fflush(stdin);
fgets(buff,80,stdin);
buff[strlen(buff)-1]='\0';
make_toks(buff,args);
if(strcmp(args[0],"list")==0)
list(args[2],args[1][0]);
else
{
pid = fork();
if(pid>0)
wait();
else
{
if(execvp(args[0],args)==-1)
printf("Bad command.\n");
}
}
}
Output :
For creating directory type mkdir directory name example mkdir newdir
cd newdir
for creating files in directory type touch text filename.txt example touch test.txt
create multiple file using same way after creating file use vim text filename.txt and write
text in text files .
return to your original directory type cd –
now run your program using ./a.out command
output - myshell$ list f newdir
test.txt
test1.txt
test2.txt
test3.txt
myshell$ list n newdir
2 Dir(s) 4 File(s)
myshell$ list i newdir
test.txt 114949
test1.txt 114945
test2.txt 4271
test3.txt 114947

-------------------------------------------------------------------------------------------------

Slip_no3

3,16,24 count

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
void make_toks(char *s, char *tok[])
{
int i=0;
char *p;
p = strtok(s," ");
while(p!=NULL)
{
tok[i++]=p;
p=strtok(NULL," ");
}
tok[i]=NULL;
}
void count(char *fn, char op)
{
int fh,cc=0,wc=0,lc=0;
char c;
fh = open(fn,O_RDONLY);
if(fh==-1)
{
printf("File %s not found.\n",fn);
return;
}
while(read(fh,&c,1)>0)
{
if(c==' ') wc++;
else if(c=='\n')
{
wc++;
lc++;
}
cc++;
}
close(fh);
switch(op)
{
case 'c':
printf("No.of characters:%d\n",cc-1);
break;
case 'w':
printf("No.of words:%d\n",wc);
break;
case 'l':
printf("No.of lines:%d\n",lc+1);
break;
}
}
int main()
{
char buff[80],*args[10];
int pid;
while(1)
{
printf("myshell$ ");
fflush(stdin);
fgets(buff,80,stdin);
buff[strlen(buff)-1]='\0';
make_toks(buff,args);
if(strcmp(args[0],"count")==0)
count(args[2],args[1][0]);
else
{
pid = fork();
if(pid>0)
wait();
else
{
if(execvp(args[0],args)==-1)
printf("Bad command.\n");
}
}
}
return 0;
}
Output :
after compile create text file
for text file type vim textfile name.txt ,example : vim info.txt
press i write text in text file press esc :wq
now run program using ./a.out command
myshell$ count c info.txt
No.of characters:45
myshell$ count w info.txt
No.of words:3
myshell$ count l info.txt
No.of lines:3
myshell$
<---info.txt--->
Hello world
Ramayan-Valmiki
Bhagwatgeeta-Vyasa


3,8,12,18 iru

#include<stdio.h>
#define MAX 20
int frames[MAX],ref[MAX],mem[MAX][MAX],faults,
sp,m,n,time[MAX];
void accept()
{
int i;
printf("Enter no.of frames:");
scanf("%d", &n);
printf("Enter no.of references:");
scanf("%d", &m);
printf("Enter reference string:\n");
for(i=0;i<m;i++)
{
printf("[%d]=",i);
scanf("%d",&ref[i]);
}
}
void disp()
{
int i,j;
for(i=0;i<m;i++)
printf("%3d",ref[i]);
printf("\n\n");
for(i=0;i<n;i++)
{
for(j=0;j<m;j++)
{
if(mem[i][j])
printf("%3d",mem[i][j]);
else
printf(" ");
}
printf("\n");
}
printf("Total Page Faults: %d\n",faults);
}
int search(int pno)
{
int i;
for(i=0;i<n;i++)
{
if(frames[i]==pno)
return i;
}
return -1;
}
int get_lru()
{
int i,min_i,min=9999;
for(i=0;i<n;i++)
{
if(time[i]<min)
{
min = time[i];
min_i = i;
}
}
return min_i;
}
void lru()
{
int i,j,k;
for(i=0;i<m && sp<n;i++)
{
k=search(ref[i]);
if(k==-1)
{
frames[sp]=ref[i];
time[sp]=i;
faults++;
sp++;
for(j=0;j<n;j++)
mem[j][i]=frames[j];
}
else
time[k]=i;
}
for(;i<m;i++)
{
k = search(ref[i]);
if(k==-1)
{
sp = get_lru();
frames[sp] = ref[i];
time[sp] = i;
faults++;
for(j=0;j<n;j++)
mem[j][i] = frames[j];
}
else
time[k]=i;
}
}
int main()
{
accept();
lru();
disp();
return 0;
}
Output:
Enter no.of frames:4
Enter no.of references:16
Enter reference string:
[0]=12
[1]=15
[2]=12
[3]=18
[4]=6
[5]=8
[6]=11
[7]=12
[8]=19
[9]=12
[10]=6
[11]=8
[12]=12
[13]=15
[14]=19
[15]=8
12 15 12 18 6 8 11 12 19 12 6 8 12 15 19 8
12 12 12 12 12 11 11 11 11 8 8 8
15 15 15 8 8 8 8 6 6 6 19
18 18 18 18 12 12 12 12 12 12
6 6 6 6 19 19 19 15 15
Total Page Faults: 12


------------------------------------------------------------------------------------------------------------

Slip_4 

4 mfu

#include<stdio.h>
#define MAX 20
int frames[MAX],ref[MAX],mem[MAX][MAX],faults,
sp,m,n,count[MAX];
void accept()
{
int i;
printf("Enter no.of frames:");
scanf("%d", &n);
printf("Enter no.of references:");
scanf("%d", &m);
printf("Enter reference string:\n");
for(i=0;i<m;i++)
{
printf("[%d]=",i);
scanf("%d",&ref[i]);
}
}
void disp()
{
int i,j;
for(i=0;i<m;i++)
printf("%3d",ref[i]);
printf("\n\n");
for(i=0;i<n;i++)
{
for(j=0;j<m;j++)
{
if(mem[i][j])
printf("%3d",mem[i][j]);
else
printf(" ");
}
printf("\n");
}
printf("Total Page Faults: %d\n",faults);
}
int search(int pno)
{
int i;
for(i=0;i<n;i++)
{
if(frames[i]==pno)
return i;
}
return -1;
}
int get_mfu(int sp)
{
int i,max_i,max=-9999;
i=sp;
do
{
if(count[i]>max)
{
max = count[i];
max_i = i;
}
i=(i+1)%n;
}while(i!=sp);
return max_i;
}
void mfu()
{
int i,j,k;
for(i=0;i<m && sp<n;i++)
{
k=search(ref[i]);
if(k==-1)
{
frames[sp]=ref[i];
count[sp]++;
faults++;
sp++;
for(j=0;j<n;j++)
mem[j][i]=frames[j];
}
else
count[k]++;
}
sp=0;
for(;i<m;i++)
{
k = search(ref[i]);
if(k==-1)
{
sp = get_mfu(sp);
frames[sp] = ref[i];
count[sp]=1;
faults++;
sp = (sp+1)%n;
for(j=0;j<n;j++)
mem[j][i] = frames[j];
}
else
count[k]++;
}
}
int main()
{
accept();
mfu();
disp();
return 0;
}
Output :
./a.out
Enter no.of frames:4
Enter no.of references:12 15 12 18 6 8 11 12 19 12 6 8 12 15 19 8
Enter reference string:
[0]=[1]=[2]=[3]=[4]=[5]=[6]=[7]=[8]=[9]=[10]=[11]= 15 12 18 6 8 11 12 19 12 6 8 12
15 15 15 15 8 8 8 8 8 12
12 12 12 12 11 11 11 11 11
18 18 18 18 12 12 6 6
6 6 6 6 19 19 19
Total Page Faults: 10

--------
 4,5,6,7,8,9,25 filePattern 


include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
void make_toks(char *s, char *tok[])
{
int i=0;
char *p;
p = strtok(s," ");
while(p!=NULL)
{
tok[i++]=p;
p=strtok(NULL," ");
}
tok[i]=NULL;
}
void search(char *fn, char op, char *pattern)
{
int fh,count=0,i=0,j=0;
char buff[255],c,*p;
fh = open(fn,O_RDONLY);
if(fh==-1)
{
printf("File %s Not Found\n",fn);
return;
}
switch(op)
{
case 'f':
while(read(fh,&c,1))
{
buff[j++]=c;
if(c=='\n')
{
buff[j]='\0';
j=0;
i++;
if(strstr(buff,pattern))
{
printf("%d: %s",i,buff);
break;
}
}
}
break;
case 'c':
while(read(fh,&c,1))
{
buff[j++]=c;
if(c=='\n')
{
buff[j]='\0';
j=0;
p = buff;
while(p=strstr(p,pattern))
{
count++;
p++;
}
}
}
printf("Total No.of Occurrences = %d\n",count);
break;
case 'a':
while(read(fh,&c,1))
{
buff[j++]=c;
if(c=='\n')
{
buff[j]='\0';
j = 0;
i++;
if(strstr(buff,pattern))
printf("%d: %s",i,buff);
}
}
}//switch
close(fh);
}//search
int main()
{
char buff[80],*args[10];
int pid;
while(1)
{
printf("myshell$");
fflush(stdin);
fgets(buff,80,stdin);
buff[strlen(buff)-1]='\0';
make_toks(buff,args);
if(strcmp(args[0],"search")==0)
search(args[3],args[1][0],args[2]);
else
{
pid = fork();
if(pid>0)
wait();
else
{
if(execvp(args[0],args)==-1)
printf("Bad command.\n");
}
}
}
return 0;
}
for output first create text file example A.txt
for create text file type vim A.txt
insert text in text file
aaaabcdfg
dfrgh
e
hii
jerr
kll
iii
qqq
type esc :wq come out from text file now run your main program
first compile program using gcc filename.c example gcc searchf.c
now run program using ./a.out
output:
myshell$search f a A.txt
1: aaaabcdfg
myshell$search a d A.txt
1: aaaabcdfg
2: dfrgh
myshell$search c i A.txt
Total No.of Occurrences = 5
myshell$

--------------------------------------------------------------------------------------------------------------


slip_no 5

4,5,,6,7,8,9,25 file pattern

include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
void make_toks(char *s, char *tok[])
{
int i=0;
char *p;
p = strtok(s," ");
while(p!=NULL)
{
tok[i++]=p;
p=strtok(NULL," ");
}
tok[i]=NULL;
}
void search(char *fn, char op, char *pattern)
{
int fh,count=0,i=0,j=0;
char buff[255],c,*p;
fh = open(fn,O_RDONLY);
if(fh==-1)
{
printf("File %s Not Found\n",fn);
return;
}
switch(op)
{
case 'f':
while(read(fh,&c,1))
{
buff[j++]=c;
if(c=='\n')
{
buff[j]='\0';
j=0;
i++;
if(strstr(buff,pattern))
{
printf("%d: %s",i,buff);
break;
}
}
}
break;
case 'c':
while(read(fh,&c,1))
{
buff[j++]=c;
if(c=='\n')
{
buff[j]='\0';
j=0;
p = buff;
while(p=strstr(p,pattern))
{
count++;
p++;
}
}
}
printf("Total No.of Occurrences = %d\n",count);
break;
case 'a':
while(read(fh,&c,1))
{
buff[j++]=c;
if(c=='\n')
{
buff[j]='\0';
j = 0;
i++;
if(strstr(buff,pattern))
printf("%d: %s",i,buff);
}
}
}//switch
close(fh);
}//search
int main()
{
char buff[80],*args[10];
int pid;
while(1)
{
printf("myshell$");
fflush(stdin);
fgets(buff,80,stdin);
buff[strlen(buff)-1]='\0';
make_toks(buff,args);
if(strcmp(args[0],"search")==0)
search(args[3],args[1][0],args[2]);
else
{
pid = fork();
if(pid>0)
wait();
else
{
if(execvp(args[0],args)==-1)
printf("Bad command.\n");
}
}
}
return 0;
}
for output first create text file example A.txt
for create text file type vim A.txt
insert text in text file
aaaabcdfg
dfrgh
e
hii
jerr
kll
iii
qqq
type esc :wq come out from text file now run your main program
first compile program using gcc filename.c example gcc searchf.c
now run program using ./a.out
output:
myshell$search f a A.txt
1: aaaabcdfg
myshell$search a d A.txt
1: aaaabcdfg
2: dfrgh
myshell$search c i A.txt
Total No.of Occurrences = 5
myshell$

------------

23,5,7,17 opt

#include<stdio.h>
int main()
{
int no_of_frames, no_of_pages, frames[10], pages[30], temp[10], flag1, flag2, flag3, i, j, k, pos,
max, faults = 0;
printf("Enter number of frames: ");
scanf("%d", &no_of_frames);
printf("Enter number of pages: ");
scanf("%d", &no_of_pages);
printf("Enter page reference string: ");
for(i = 0; i < no_of_pages; ++i){
scanf("%d", &pages[i]);
}
for(i = 0; i < no_of_frames; ++i){
frames[i] = -1;
}
for(i = 0; i < no_of_pages; ++i){
flag1 = flag2 = 0;
for(j = 0; j < no_of_frames; ++j){
if(frames[j] == pages[i]){
flag1 = flag2 = 1;
break;
}
}
if(flag1 == 0){
for(j = 0; j < no_of_frames; ++j){
if(frames[j] == -1){
faults++;
frames[j] = pages[i];
flag2 = 1;
break;
}
}
}
if(flag2 == 0){
flag3 =0;
for(j = 0; j < no_of_frames; ++j){
temp[j] = -1;
for(k = i + 1; k < no_of_pages; ++k){
if(frames[j] == pages[k]){
temp[j] = k;
break;
}
}
}
for(j = 0; j < no_of_frames; ++j){
if(temp[j] == -1){
pos = j;
flag3 = 1;
break;
}
}
if(flag3 ==0){
max = temp[0];
pos = 0;
for(j = 1; j < no_of_frames; ++j){
if(temp[j] > max){
max = temp[j];
pos = j;
}
}
}
frames[pos] = pages[i];
faults++;
}
printf("\n");
for(j = 0; j < no_of_frames; ++j){
printf("%d\t", frames[j]);
}
}
printf("\n\nTotal Page Faults = %d", faults);
return 0;
}
Output:
./a.out
Enter number of frames: 4
Enter number of pages: 12 15 12 18 6 8 11 12 19 12 6 8 12 15 19 8
Enter page reference string:
15 -1 -1 -1
15 12 -1 -1
15 12 18 -1
15 12 18 6
8 12 18 6
8 12 11 6
8 12 11 6
8 12 19 6
8 12 19 6
8 12 19 6
8 12 19 6
8 12 19 6
Total Page Faults = 7

----------------------------------------------------------------------------------------------------------------------

slip no 6 

4,5,,6,7,8,9,25 file pattern

include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
void make_toks(char *s, char *tok[])
{
int i=0;
char *p;
p = strtok(s," ");
while(p!=NULL)
{
tok[i++]=p;
p=strtok(NULL," ");
}
tok[i]=NULL;
}
void search(char *fn, char op, char *pattern)
{
int fh,count=0,i=0,j=0;
char buff[255],c,*p;
fh = open(fn,O_RDONLY);
if(fh==-1)
{
printf("File %s Not Found\n",fn);
return;
}
switch(op)
{
case 'f':
while(read(fh,&c,1))
{
buff[j++]=c;
if(c=='\n')
{
buff[j]='\0';
j=0;
i++;
if(strstr(buff,pattern))
{
printf("%d: %s",i,buff);
break;
}
}
}
break;
case 'c':
while(read(fh,&c,1))
{
buff[j++]=c;
if(c=='\n')
{
buff[j]='\0';
j=0;
p = buff;
while(p=strstr(p,pattern))
{
count++;
p++;
}
}
}
printf("Total No.of Occurrences = %d\n",count);
break;
case 'a':
while(read(fh,&c,1))
{
buff[j++]=c;
if(c=='\n')
{
buff[j]='\0';
j = 0;
i++;
if(strstr(buff,pattern))
printf("%d: %s",i,buff);
}
}
}//switch
close(fh);
}//search
int main()
{
char buff[80],*args[10];
int pid;
while(1)
{
printf("myshell$");
fflush(stdin);
fgets(buff,80,stdin);
buff[strlen(buff)-1]='\0';
make_toks(buff,args);
if(strcmp(args[0],"search")==0)
search(args[3],args[1][0],args[2]);
else
{
pid = fork();
if(pid>0)
wait();
else
{
if(execvp(args[0],args)==-1)
printf("Bad command.\n");
}
}
}
return 0;
}
for output first create text file example A.txt
for create text file type vim A.txt
insert text in text file
aaaabcdfg
dfrgh
e
hii
jerr
kll
iii
qqq
type esc :wq come out from text file now run your main program
first compile program using gcc filename.c example gcc searchf.c
now run program using ./a.out
output:
myshell$search f a A.txt
1: aaaabcdfg
myshell$search a d A.txt
1: aaaabcdfg
2: dfrgh
myshell$search c i A.txt
Total No.of Occurrences = 5
myshell$

--------------------

23,5,7,17 opt

#include<stdio.h>
int main()
{
int no_of_frames, no_of_pages, frames[10], pages[30], temp[10], flag1, flag2, flag3, i, j, k, pos,
max, faults = 0;
printf("Enter number of frames: ");
scanf("%d", &no_of_frames);
printf("Enter number of pages: ");
scanf("%d", &no_of_pages);
printf("Enter page reference string: ");
for(i = 0; i < no_of_pages; ++i){
scanf("%d", &pages[i]);
}
for(i = 0; i < no_of_frames; ++i){
frames[i] = -1;
}
for(i = 0; i < no_of_pages; ++i){
flag1 = flag2 = 0;
for(j = 0; j < no_of_frames; ++j){
if(frames[j] == pages[i]){
flag1 = flag2 = 1;
break;
}
}
if(flag1 == 0){
for(j = 0; j < no_of_frames; ++j){
if(frames[j] == -1){
faults++;
frames[j] = pages[i];
flag2 = 1;
break;
}
}
}
if(flag2 == 0){
flag3 =0;
for(j = 0; j < no_of_frames; ++j){
temp[j] = -1;
for(k = i + 1; k < no_of_pages; ++k){
if(frames[j] == pages[k]){
temp[j] = k;
break;
}
}
}
for(j = 0; j < no_of_frames; ++j){
if(temp[j] == -1){
pos = j;
flag3 = 1;
break;
}
}
if(flag3 ==0){
max = temp[0];
pos = 0;
for(j = 1; j < no_of_frames; ++j){
if(temp[j] > max){
max = temp[j];
pos = j;
}
}
}
frames[pos] = pages[i];
faults++;
}
printf("\n");
for(j = 0; j < no_of_frames; ++j){
printf("%d\t", frames[j]);
}
}
printf("\n\nTotal Page Faults = %d", faults);
return 0;
}
Output:
./a.out
Enter number of frames: 4
Enter number of pages: 12 15 12 18 6 8 11 12 19 12 6 8 12 15 19 8
Enter page reference string:
15 -1 -1 -1
15 12 -1 -1
15 12 18 -1
15 12 18 6
8 12 18 6
8 12 11 6
8 12 11 6
8 12 19 6
8 12 19 6
8 12 19 6
8 12 19 6
8 12 19 6
Total Page Faults = 7

-------------------------------------------------------------------------------------------------------------------------------------

Slip_ no 8

3,8,12,18 iru 

#include<stdio.h>
#define MAX 20
int frames[MAX],ref[MAX],mem[MAX][MAX],faults,
sp,m,n,time[MAX];
void accept()
{
int i;
printf("Enter no.of frames:");
scanf("%d", &n);
printf("Enter no.of references:");
scanf("%d", &m);
printf("Enter reference string:\n");
for(i=0;i<m;i++)
{
printf("[%d]=",i);
scanf("%d",&ref[i]);
}
}
void disp()
{
int i,j;
for(i=0;i<m;i++)
printf("%3d",ref[i]);
printf("\n\n");
for(i=0;i<n;i++)
{
for(j=0;j<m;j++)
{
if(mem[i][j])
printf("%3d",mem[i][j]);
else
printf(" ");
}
printf("\n");
}
printf("Total Page Faults: %d\n",faults);
}
int search(int pno)
{
int i;
for(i=0;i<n;i++)
{
if(frames[i]==pno)
return i;
}
return -1;
}
int get_lru()
{
int i,min_i,min=9999;
for(i=0;i<n;i++)
{
if(time[i]<min)
{
min = time[i];
min_i = i;
}
}
return min_i;
}
void lru()
{
int i,j,k;
for(i=0;i<m && sp<n;i++)
{
k=search(ref[i]);
if(k==-1)
{
frames[sp]=ref[i];
time[sp]=i;
faults++;
sp++;
for(j=0;j<n;j++)
mem[j][i]=frames[j];
}
else
time[k]=i;
}
for(;i<m;i++)
{
k = search(ref[i]);
if(k==-1)
{
sp = get_lru();
frames[sp] = ref[i];
time[sp] = i;
faults++;
for(j=0;j<n;j++)
mem[j][i] = frames[j];
}
else
time[k]=i;
}
}
int main()
{
accept();
lru();
disp();
return 0;
}
Output:
Enter no.of frames:4
Enter no.of references:16
Enter reference string:
[0]=12
[1]=15
[2]=12
[3]=18
[4]=6
[5]=8
[6]=11
[7]=12
[8]=19
[9]=12
[10]=6
[11]=8
[12]=12
[13]=15
[14]=19
[15]=8
12 15 12 18 6 8 11 12 19 12 6 8 12 15 19 8
12 12 12 12 12 11 11 11 11 8 8 8
15 15 15 8 8 8 8 6 6 6 19
18 18 18 18 12 12 12 12 12 12
6 6 6 6 19 19 19 15 15
Total Page Faults: 12

----------------------

4,5,,6,7,8,9,25 file pattern

include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
void make_toks(char *s, char *tok[])
{
int i=0;
char *p;
p = strtok(s," ");
while(p!=NULL)
{
tok[i++]=p;
p=strtok(NULL," ");
}
tok[i]=NULL;
}
void search(char *fn, char op, char *pattern)
{
int fh,count=0,i=0,j=0;
char buff[255],c,*p;
fh = open(fn,O_RDONLY);
if(fh==-1)
{
printf("File %s Not Found\n",fn);
return;
}
switch(op)
{
case 'f':
while(read(fh,&c,1))
{
buff[j++]=c;
if(c=='\n')
{
buff[j]='\0';
j=0;
i++;
if(strstr(buff,pattern))
{
printf("%d: %s",i,buff);
break;
}
}
}
break;
case 'c':
while(read(fh,&c,1))
{
buff[j++]=c;
if(c=='\n')
{
buff[j]='\0';
j=0;
p = buff;
while(p=strstr(p,pattern))
{
count++;
p++;
}
}
}
printf("Total No.of Occurrences = %d\n",count);
break;
case 'a':
while(read(fh,&c,1))
{
buff[j++]=c;
if(c=='\n')
{
buff[j]='\0';
j = 0;
i++;
if(strstr(buff,pattern))
printf("%d: %s",i,buff);
}
}
}//switch
close(fh);
}//search
int main()
{
char buff[80],*args[10];
int pid;
while(1)
{
printf("myshell$");
fflush(stdin);
fgets(buff,80,stdin);
buff[strlen(buff)-1]='\0';
make_toks(buff,args);
if(strcmp(args[0],"search")==0)
search(args[3],args[1][0],args[2]);
else
{
pid = fork();
if(pid>0)
wait();
else
{
if(execvp(args[0],args)==-1)
printf("Bad command.\n");
}
}
}
return 0;
}
for output first create text file example A.txt
for create text file type vim A.txt
insert text in text file
aaaabcdfg
dfrgh
e
hii
jerr
kll
iii
qqq
type esc :wq come out from text file now run your main program
first compile program using gcc filename.c example gcc searchf.c
now run program using ./a.out
output:
myshell$search f a A.txt
1: aaaabcdfg
myshell$search a d A.txt
1: aaaabcdfg
2: dfrgh
myshell$search c i A.txt
Total No.of Occurrences = 5
myshell$

-----------------------------------------------------------------------------------------------------------------------------

slip no 9 

2a,9,10  fifo 

#include<stdio.h>
#define MAX 20
int frames[MAX],ref[MAX],mem[MAX][MAX],faults,sp,m,n;
void accept()
{
int i;
printf("Enter no.of frames:");
scanf("%d", &n);
printf("Enter no.of references:");
scanf("%d", &m);
printf("Enter reference string:\n");
for(i=0;i<m;i++)
{
printf("[%d]=",i);
scanf("%d",&ref[i]);
}
}
void disp()
{
int i,j;
for(i=0;i<m;i++)
printf("%3d",ref[i]);
printf("\n\n");
for(i=0;i<n;i++)
{
for(j=0;j<m;j++)
{
if(mem[i][j])
printf("%3d",mem[i][j]);
else
printf(" ");
}
printf("\n");
}
printf("Total Page Faults: %d\n",faults);
}
int search(int pno)
{
int i;
for(i=0;i<n;i++)
{
if(frames[i]==pno)
return i;
}
return -1;
}
void fifo()
{
int i,j;
for(i=0;i<m;i++)
{
if(search(ref[i])==-1)
{
frames[sp] = ref[i];
sp = (sp+1)%n;
faults++;
for(j=0;j<n;j++)
mem[j][i] = frames[j];
}
}
}
int main()
{
accept();
fifo();
disp();
return 0;
}
Output:
Enter no.of frames:3
Enter no.of references:16
Enter reference string:
[0]=12
[1]=15
[2]=12
[3]=18
[4]=6
[5]=8
[6]=11
[7]=12
[8]=19
[9]=12
[10]=6
[11]=8
[12]=12
[13]=15
[14]=19
[15]=8
12 15 12 18 6 8 11 12 19 12 6 8 12 15 19 8
12 12 12 6 6 6 12 12 12 8 8 8 19 19
15 15 15 8 8 8 19 19 19 12 12 12 8
18 18 18 11 11 11 6 6 6 15 15 15
Total Page Faults: 14

------------------------------


4,5,,6,7,8,9,25 file pattern

include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
void make_toks(char *s, char *tok[])
{
int i=0;
char *p;
p = strtok(s," ");
while(p!=NULL)
{
tok[i++]=p;
p=strtok(NULL," ");
}
tok[i]=NULL;
}
void search(char *fn, char op, char *pattern)
{
int fh,count=0,i=0,j=0;
char buff[255],c,*p;
fh = open(fn,O_RDONLY);
if(fh==-1)
{
printf("File %s Not Found\n",fn);
return;
}
switch(op)
{
case 'f':
while(read(fh,&c,1))
{
buff[j++]=c;
if(c=='\n')
{
buff[j]='\0';
j=0;
i++;
if(strstr(buff,pattern))
{
printf("%d: %s",i,buff);
break;
}
}
}
break;
case 'c':
while(read(fh,&c,1))
{
buff[j++]=c;
if(c=='\n')
{
buff[j]='\0';
j=0;
p = buff;
while(p=strstr(p,pattern))
{
count++;
p++;
}
}
}
printf("Total No.of Occurrences = %d\n",count);
break;
case 'a':
while(read(fh,&c,1))
{
buff[j++]=c;
if(c=='\n')
{
buff[j]='\0';
j = 0;
i++;
if(strstr(buff,pattern))
printf("%d: %s",i,buff);
}
}
}//switch
close(fh);
}//search
int main()
{
char buff[80],*args[10];
int pid;
while(1)
{
printf("myshell$");
fflush(stdin);
fgets(buff,80,stdin);
buff[strlen(buff)-1]='\0';
make_toks(buff,args);
if(strcmp(args[0],"search")==0)
search(args[3],args[1][0],args[2]);
else
{
pid = fork();
if(pid>0)
wait();
else
{
if(execvp(args[0],args)==-1)
printf("Bad command.\n");
}
}
}
return 0;
}
for output first create text file example A.txt
for create text file type vim A.txt
insert text in text file
aaaabcdfg
dfrgh
e
hii
jerr
kll
iii
qqq
type esc :wq come out from text file now run your main program
first compile program using gcc filename.c example gcc searchf.c
now run program using ./a.out
output:
myshell$search f a A.txt
1: aaaabcdfg
myshell$search a d A.txt
1: aaaabcdfg
2: dfrgh
myshell$search c i A.txt
Total No.of Occurrences = 5
myshell$

------------------------------------------------------------------------------------------------------------------------------------------

slip no 10 

2a,9,10  fifo 

#include<stdio.h>
#define MAX 20
int frames[MAX],ref[MAX],mem[MAX][MAX],faults,sp,m,n;
void accept()
{
int i;
printf("Enter no.of frames:");
scanf("%d", &n);
printf("Enter no.of references:");
scanf("%d", &m);
printf("Enter reference string:\n");
for(i=0;i<m;i++)
{
printf("[%d]=",i);
scanf("%d",&ref[i]);
}
}
void disp()
{
int i,j;
for(i=0;i<m;i++)
printf("%3d",ref[i]);
printf("\n\n");
for(i=0;i<n;i++)
{
for(j=0;j<m;j++)
{
if(mem[i][j])
printf("%3d",mem[i][j]);
else
printf(" ");
}
printf("\n");
}
printf("Total Page Faults: %d\n",faults);
}
int search(int pno)
{
int i;
for(i=0;i<n;i++)
{
if(frames[i]==pno)
return i;
}
return -1;
}
void fifo()
{
int i,j;
for(i=0;i<m;i++)
{
if(search(ref[i])==-1)
{
frames[sp] = ref[i];
sp = (sp+1)%n;
faults++;
for(j=0;j<n;j++)
mem[j][i] = frames[j];
}
}
}
int main()
{
accept();
fifo();
disp();
return 0;
}
Output:
Enter no.of frames:3
Enter no.of references:16
Enter reference string:
[0]=12
[1]=15
[2]=12
[3]=18
[4]=6
[5]=8
[6]=11
[7]=12
[8]=19
[9]=12
[10]=6
[11]=8
[12]=12
[13]=15
[14]=19
[15]=8
12 15 12 18 6 8 11 12 19 12 6 8 12 15 19 8
12 12 12 6 6 6 12 12 12 8 8 8 19 19
15 15 15 8 8 8 19 19 19 12 12 12 8
18 18 18 11 11 11 6 6 6 15 15 15
Total Page Faults: 14

------------------------------

2b,10,11,12,15,19 search dir 

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
void make_toks(char *s, char *tok[])
{
int i=0;
char *p;
p = strtok(s," ");
while(p!=NULL)
{
tok[i++]=p;
p=strtok(NULL," ");
}
tok[i]=NULL;
}
void list(char *dn, char op)
{
DIR *dp;
struct dirent *entry;
int dc=0,fc=0;
dp = opendir(dn);
if(dp==NULL)
{
printf("Dir %s not found.\n",dn);
return;
}
switch(op)
{
case 'f':
while(entry=readdir(dp))
{
if(entry->d_type==DT_REG)
printf("%s\n",entry->d_name);
}
break;
case 'n':
while(entry=readdir(dp))
{
if(entry->d_type==DT_DIR)
dc++;
if(entry->d_type==DT_REG)
fc++;
}
printf("%d Dir(s)\t%d File(s)\n",dc,fc);
break;
case 'i':
while(entry=readdir(dp))
{
if(entry->d_type==DT_REG)
printf("%s\t%d\n",entry->d_name,entry->d_fileno);
}
}
closedir(dp);
}
int main()
{
char buff[80],*args[10];
int pid;
while(1)
{
printf("\nmyshell$");
fflush(stdin);
fgets(buff,80,stdin);
buff[strlen(buff)-1]='\0';
make_toks(buff,args);
if(strcmp(args[0],"list")==0)
list(args[2],args[1][0]);
else
{
pid = fork();
if(pid>0)
wait();
else
{
if(execvp(args[0],args)==-1)
printf("Bad command.\n");
}
}
}
Output :
For creating directory type mkdir directory name example mkdir newdir
cd newdir
for creating files in directory type touch text filename.txt example touch test.txt
create multiple file using same way after creating file use vim text filename.txt and write
text in text files .
return to your original directory type cd –
now run your program using ./a.out command
output - myshell$ list f newdir
test.txt
test1.txt
test2.txt
test3.txt
myshell$ list n newdir
2 Dir(s) 4 File(s)
myshell$ list i newdir
test.txt 114949
test1.txt 114945
test2.txt 4271
test3.txt 114947

------------------------------------------------------------------------------------------------------------------------------------------

slip no 12 


2b,10,11,12,15,19 search dir 

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
void make_toks(char *s, char *tok[])
{
int i=0;
char *p;
p = strtok(s," ");
while(p!=NULL)
{
tok[i++]=p;
p=strtok(NULL," ");
}
tok[i]=NULL;
}
void list(char *dn, char op)
{
DIR *dp;
struct dirent *entry;
int dc=0,fc=0;
dp = opendir(dn);
if(dp==NULL)
{
printf("Dir %s not found.\n",dn);
return;
}
switch(op)
{
case 'f':
while(entry=readdir(dp))
{
if(entry->d_type==DT_REG)
printf("%s\n",entry->d_name);
}
break;
case 'n':
while(entry=readdir(dp))
{
if(entry->d_type==DT_DIR)
dc++;
if(entry->d_type==DT_REG)
fc++;
}
printf("%d Dir(s)\t%d File(s)\n",dc,fc);
break;
case 'i':
while(entry=readdir(dp))
{
if(entry->d_type==DT_REG)
printf("%s\t%d\n",entry->d_name,entry->d_fileno);
}
}
closedir(dp);
}
int main()
{
char buff[80],*args[10];
int pid;
while(1)
{
printf("\nmyshell$");
fflush(stdin);
fgets(buff,80,stdin);
buff[strlen(buff)-1]='\0';
make_toks(buff,args);
if(strcmp(args[0],"list")==0)
list(args[2],args[1][0]);
else
{
pid = fork();
if(pid>0)
wait();
else
{
if(execvp(args[0],args)==-1)
printf("Bad command.\n");
}
}
}
Output :
For creating directory type mkdir directory name example mkdir newdir
cd newdir
for creating files in directory type touch text filename.txt example touch test.txt
create multiple file using same way after creating file use vim text filename.txt and write
text in text files .
return to your original directory type cd –
now run your program using ./a.out command
output - myshell$ list f newdir
test.txt
test1.txt
test2.txt
test3.txt
myshell$ list n newdir
2 Dir(s) 4 File(s)
myshell$ list i newdir
test.txt 114949
test1.txt 114945
test2.txt 4271
test3.txt 114947

----------------------

3,8,12,18 iru 

#include<stdio.h>
#define MAX 20
int frames[MAX],ref[MAX],mem[MAX][MAX],faults,
sp,m,n,time[MAX];
void accept()
{
int i;
printf("Enter no.of frames:");
scanf("%d", &n);
printf("Enter no.of references:");
scanf("%d", &m);
printf("Enter reference string:\n");
for(i=0;i<m;i++)
{
printf("[%d]=",i);
scanf("%d",&ref[i]);
}
}
void disp()
{
int i,j;
for(i=0;i<m;i++)
printf("%3d",ref[i]);
printf("\n\n");
for(i=0;i<n;i++)
{
for(j=0;j<m;j++)
{
if(mem[i][j])
printf("%3d",mem[i][j]);
else
printf(" ");
}
printf("\n");
}
printf("Total Page Faults: %d\n",faults);
}
int search(int pno)
{
int i;
for(i=0;i<n;i++)
{
if(frames[i]==pno)
return i;
}
return -1;
}
int get_lru()
{
int i,min_i,min=9999;
for(i=0;i<n;i++)
{
if(time[i]<min)
{
min = time[i];
min_i = i;
}
}
return min_i;
}
void lru()
{
int i,j,k;
for(i=0;i<m && sp<n;i++)
{
k=search(ref[i]);
if(k==-1)
{
frames[sp]=ref[i];
time[sp]=i;
faults++;
sp++;
for(j=0;j<n;j++)
mem[j][i]=frames[j];
}
else
time[k]=i;
}
for(;i<m;i++)
{
k = search(ref[i]);
if(k==-1)
{
sp = get_lru();
frames[sp] = ref[i];
time[sp] = i;
faults++;
for(j=0;j<n;j++)
mem[j][i] = frames[j];
}
else
time[k]=i;
}
}
int main()
{
accept();
lru();
disp();
return 0;
}
Output:
Enter no.of frames:4
Enter no.of references:16
Enter reference string:
[0]=12
[1]=15
[2]=12
[3]=18
[4]=6
[5]=8
[6]=11
[7]=12
[8]=19
[9]=12
[10]=6
[11]=8
[12]=12
[13]=15
[14]=19
[15]=8
12 15 12 18 6 8 11 12 19 12 6 8 12 15 19 8
12 12 12 12 12 11 11 11 11 8 8 8
15 15 15 8 8 8 8 6 6 6 19
18 18 18 18 12 12 12 12 12 12
6 6 6 6 19 19 19 15 15
Total Page Faults: 12

------------------------------------------------------------------------------------------------------------------------------------------

slip no  13



1b,13,14,20 typeline

#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <unistd.h>
int make_toks(char *s, char *tok[]) {
int i = 0;
char *p;
p = strtok(s, " ");
while(p != NULL) {
tok[i++] = p;
p = strtok(NULL, " ");
}
tok[i] = NULL;
return i;
}
void typeline(char *op, char *fn) {
int fh,
i,
j,
n;
char c;
fh = open(fn, O_RDONLY);
if(fh == -1) {
printf("File %s not found.\n", fn);
return;
}
if(strcmp(op, "a") == 0) {
while(read(fh, &c, 1) > 0)
printf("%c", c);
close(fh);
return;
}
n = atoi(op);
if(n > 0) {
i = 0;
while(read(fh, &c, 1) > 0) {
printf("%c", c);
if(c == '\n') i++;
if(i == n) break;
}
}
if(n < 0) {
i = 0;
while(read(fh, &c, 1) > 0) {
if(c == '\n') i++;
}
lseek(fh, 0, SEEK_SET);
j = 0;
while(read(fh, &c, 1) > 0) {
if(c == '\n') j++;
if(j == i+n+1) break;
}
while(read(fh, &c, 1) > 0) {
printf("%c", c);
}
}
close(fh);
}
int main() {
char buff[80],
*args[10];
while(1) {
printf ("\n");
printf("\nmyshell$ ");
fgets(buff, 80, stdin);
buff[strlen(buff)-1] = '\0';
int n = make_toks(buff, args);
switch (n) {
case 1:
if(strcmp(args[0], "exit") == 0)
exit(1);
if (!fork())
execlp (args [0], args[0], NULL);
break;
case 2:
if (!fork ())
execlp (args [0], args[0], args[1], NULL);
break;
case 3:
if (strcmp(args[0], "typeline") == 0)
typeline (args[1], args[2]);
else {
if (!fork ())
execlp (args [0], args[0], args[1], args[2], NULL);
}
break;
case 4:
if (!fork ())
execlp (args [0], args [0], args [1], args [2], args [3], NULL);
break;
}
}
return 0;
}
o/p:
create text file after compile for text file type vim text.txt insert data in text file press esc
:wq now run your program using ./a.out
myshell$ typeline a text.txt
pune
kolkata
doremon
mumbai
vadapav
chandigarh
pune
prisonbreak
pogo
misalpav
gogo
pune
\0
myshell$ typeline 3 text.txt
pune
kolkata
doremon
myshell$ typeline -5 text.txt
pogo
misalpav
gogo
pune

----------------------

13,19 round robin

Write the program to simulate Round Robin (RR) scheduling. The arrival time and first
CPU-burst for different n number of processes should be input to the algorithm. Also
give the time quantum as input. Assume the fixed IO waiting time (2 units). The next
CPU-burst should be generated randomly. The output should give Gantt chart,
turnaround time and waiting time for each process. Also find the average waiting time
and turnaround time.
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct process_info
{
char pname[20];
int at,bt,ct,bt1;
struct process_info *next;
}NODE;
int n,ts;
NODE *first,*last;
void accept_info()
{
NODE *p;
int i;
printf("Enter no.of process:");
scanf("%d",&n);
for(i=0;i<n;i++)
{
p = (NODE*)malloc(sizeof(NODE));
printf("Enter process name:");
scanf("%s",p->pname);
printf("Enter arrival time:");
scanf("%d",&p->at);
printf("Enter first CPU burst time:");
scanf("%d",&p->bt);
p->bt1 = p->bt;
p->next = NULL;
if(first==NULL)
first=p;
else
last->next=p;
last = p;
}
printf("Enter time slice:");
scanf("%d",&ts);
}
void print_output()
{
NODE *p;
float avg_tat=0,avg_wt=0;
printf("pname\tat\tbt\tct\ttat\twt\n");
p = first;
while(p!=NULL)
{
int tat = p->ct-p->at;
int wt = tat-p->bt;
avg_tat+=tat;
avg_wt+=wt;
printf("%s\t%d\t%d\t%d\t%d\t%d\n",
p->pname,p->at,p->bt,p->ct,tat,wt);
p=p->next;
}
printf("Avg TAT=%f\tAvg WT=%f\n",
avg_tat/n,avg_wt/n);
}
void print_input()
{
NODE *p;
p = first;
printf("pname\tat\tbt\n");
while(p!=NULL)
{
printf("%s\t%d\t%d\n",
p->pname,p->at,p->bt1);
p = p->next;
}
}
void sort()
{
NODE *p,*q;
int t;
char name[20];
p = first;
while(p->next!=NULL)
{
q=p->next;
while(q!=NULL)
{
if(p->at > q->at)
{
strcpy(name,p->pname);
strcpy(p->pname,q->pname);
strcpy(q->pname,name);
t = p->at;
p->at = q->at;
q->at = t;
t = p->bt;
p->bt = q->bt;
q->bt = t;
t = p->ct;
p->ct = q->ct;
q->ct = t;
t = p->bt1;
p->bt1 = q->bt1;
q->bt1 = t;
}
q=q->next;
}
p=p->next;
}
}
int time;
int is_arrived()
{
NODE *p;
p = first;
while(p!=NULL)
{
if(p->at<=time && p->bt1!=0)
return 1;
p=p->next;
}
return 0;
}
NODE * delq()
{
NODE *t;
t = first;
first = first->next;
t->next=NULL;
return t;
}
void addq(NODE *t)
{
last->next = t;
last = t;
}
struct gantt_chart
{
int start;
char pname[30];
int end;
}s[100],s1[100];
int k;
void rr()
{
int prev=0,n1=0;
NODE *p;
while(n1!=n)
{
if(!is_arrived())
{
time++;
s[k].start = prev;
strcpy(s[k].pname,"*");
s[k].end = time;
k++;
prev=time;
}
else
{
p = first;
while(1)
{
if(p->at<=time && p->bt1!=0)
break;
p = delq();
addq(p);
p = first;
}
if(p->bt1<=ts)
{
time+=p->bt1;
p->bt1=0;
}
else
{
time+=ts;
p->bt1-=ts;
}
p->ct = time;
s[k].start = prev;
strcpy(s[k].pname,p->pname);
s[k].end = time;
k++;
prev = time;
if(p->bt1==0) n1++;
p = delq();
addq(p);
}
print_input();
}
}
void print_gantt_chart()
{
int i,j,m;
s1[0] = s[0];
for(i=1,j=0;i<k;i++)
{
if(strcmp(s[i].pname,s1[j].pname)==0)
s1[j].end = s[i].end;
else
s1[++j] = s[i];
}
printf("%d",s1[0].start);
for(i=0;i<=j;i++)
{
m = (s1[i].end - s1[i].start);
for(k=0;k<m/2;k++)
printf("-");
printf("%s",s1[i].pname);
for(k=0;k<(m+1)/2;k++)
printf("-");
printf("%d",s1[i].end);
}
}
int main()
{
accept_info();
sort();
rr();
print_output();
print_gantt_chart();
return 0;
}
/tmp/k2Oz1QGNYG.o
Enter no.of process:3
Enter process name:P1
Enter arrival time:1
Enter first CPU burst time:3
Enter process name:P2
Enter arrival time:2
Enter first CPU burst time:2
Enter process name:P3
Enter arrival time:0
Enter first CPU burst time:5
Enter time slice:1
pn at bt
P1 1 3
P2 2 2
P3 0 4
pn at bt
P2 2 2
P3 0 4
P1 1 2
pn at bt
P3 0 4
P1 1 2
P2 2 1
pn at bt
P1 1 2
P2 2 1
P3 0 3
pn at bt
P2 2 1
P3 0 3
P1 1 1
pn at bt
P3 0 3
P1 1 1
P2 2 0
pn at bt
P1 1 1
P2 2 0
P3 0 2
pn at bt
P2 2 0
P3 0 2
P1 1 0
pn at bt
P1 1 0
P2 2 0
P3 0 1
pn at bt
P1 1 0
P2 2 0
P3 0 0
pn at bt ct tat wt
P1 1 3 8 7 4
P2 2 2 6 4 2
P3 0 5 10 10 5
Avg TAT=7.000000 Avg WT=3.666667
0P3-1P1-2P2-3P3-4P1-5P2-6P3-7P1-8-P3-10


------------------------------------------------------------------------------------------------------------------------------------------

slip no 14 

1b,13,14,20 typeline

#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <unistd.h>
int make_toks(char *s, char *tok[]) {
int i = 0;
char *p;
p = strtok(s, " ");
while(p != NULL) {
tok[i++] = p;
p = strtok(NULL, " ");
}
tok[i] = NULL;
return i;
}
void typeline(char *op, char *fn) {
int fh,
i,
j,
n;
char c;
fh = open(fn, O_RDONLY);
if(fh == -1) {
printf("File %s not found.\n", fn);
return;
}
if(strcmp(op, "a") == 0) {
while(read(fh, &c, 1) > 0)
printf("%c", c);
close(fh);
return;
}
n = atoi(op);
if(n > 0) {
i = 0;
while(read(fh, &c, 1) > 0) {
printf("%c", c);
if(c == '\n') i++;
if(i == n) break;
}
}
if(n < 0) {
i = 0;
while(read(fh, &c, 1) > 0) {
if(c == '\n') i++;
}
lseek(fh, 0, SEEK_SET);
j = 0;
while(read(fh, &c, 1) > 0) {
if(c == '\n') j++;
if(j == i+n+1) break;
}
while(read(fh, &c, 1) > 0) {
printf("%c", c);
}
}
close(fh);
}
int main() {
char buff[80],
*args[10];
while(1) {
printf ("\n");
printf("\nmyshell$ ");
fgets(buff, 80, stdin);
buff[strlen(buff)-1] = '\0';
int n = make_toks(buff, args);
switch (n) {
case 1:
if(strcmp(args[0], "exit") == 0)
exit(1);
if (!fork())
execlp (args [0], args[0], NULL);
break;
case 2:
if (!fork ())
execlp (args [0], args[0], args[1], NULL);
break;
case 3:
if (strcmp(args[0], "typeline") == 0)
typeline (args[1], args[2]);
else {
if (!fork ())
execlp (args [0], args[0], args[1], args[2], NULL);
}
break;
case 4:
if (!fork ())
execlp (args [0], args [0], args [1], args [2], args [3], NULL);
break;
}
}
return 0;
}
o/p:
create text file after compile for text file type vim text.txt insert data in text file press esc
:wq now run your program using ./a.out
myshell$ typeline a text.txt
pune
kolkata
doremon
mumbai
vadapav
chandigarh
pune
prisonbreak
pogo
misalpav
gogo
pune
\0
myshell$ typeline 3 text.txt
pune
kolkata
doremon
myshell$ typeline -5 text.txt
pogo
misalpav
gogo
pune

---------------------------

14,20 non preemtive sjf 

Write the program to simulate Non-preemptive Shortest Job First (SJF) -scheduling. The
arrival time and first CPU-burst for different n number of processes should be input to the
algorithm. Assume the fixed IO waiting time (2 units). The next CPU-burst should be
generated randomly. The output should give Gantt chart, turnaround time and waiting time
for each process. Also find the average waiting time and turnaround time.
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct process_info
{
char pname[20];
int at,bt,ct,bt1;
struct process_info *next;
}NODE;
int n;
NODE *first,*last;
void accept_info()
{
NODE *p;
int i;
printf("Enter no.of process:");
scanf("%d",&n);
for(i=0;i<n;i++)
{
p = (NODE*)malloc(sizeof(NODE));
printf("Enter process name:");
scanf("%s",p->pname);
printf("Enter arrival time:");
scanf("%d",&p->at);
printf("Enter first CPU burst time:");
scanf("%d",&p->bt);
p->bt1 = p->bt;
p->next = NULL;
if(first==NULL)
first=p;
else
last->next=p;
last = p;
}
}
void print_output()
{
NODE *p;
float avg_tat=0,avg_wt=0;
printf("pname\tat\tbt\tct\ttat\twt\n");
p = first;
while(p!=NULL)
{
int tat = p->ct-p->at;
int wt = tat-p->bt;
avg_tat+=tat;
avg_wt+=wt;
printf("%s\t%d\t%d\t%d\t%d\t%d\n",
p->pname,p->at,p->bt,p->ct,tat,wt);
p=p->next;
}
printf("Avg TAT=%f\tAvg WT=%f\n",
avg_tat/n,avg_wt/n);
}
void print_input()
{
NODE *p;
p = first;
printf("pname\tat\tbt\n");
while(p!=NULL)
{
printf("%s\t%d\t%d\n",
p->pname,p->at,p->bt1);
p = p->next;
}
}
void sort()
{
NODE *p,*q;
int t;
char name[20];
p = first;
while(p->next!=NULL)
{
q=p->next;
while(q!=NULL)
{
if(p->at > q->at)
{
strcpy(name,p->pname);
strcpy(p->pname,q->pname);
strcpy(q->pname,name);
t = p->at;
p->at = q->at;
q->at = t;
t = p->bt;
p->bt = q->bt;
q->bt = t;
t = p->ct;
p->ct = q->ct;
q->ct = t;
t = p->bt1;
p->bt1 = q->bt1;
q->bt1 = t;
}
q=q->next;
}
p=p->next;
}
}
int time;
NODE * get_sjf()
{
NODE *p,*min_p=NULL;
int min=9999;
p = first;
while(p!=NULL)
{
if(p->at<=time && p->bt1!=0 &&
p->bt1<min)
{
min = p->bt1;
min_p = p;
}
p=p->next;
}
return min_p;
}
struct gantt_chart
{
int start;
char pname[30];
int end;
}s[100],s1[100];
int k;
void sjfnp()
{
int prev=0,n1=0;
NODE *p;
while(n1!=n)
{
p = get_sjf();
if(p==NULL)
{
time++;
s[k].start = prev;
strcpy(s[k].pname,"*");
s[k].end = time;
prev = time;
k++;
}
else
{
time+=p->bt1;
s[k].start = prev;
strcpy(s[k].pname, p->pname);
s[k].end = time;
prev = time;
k++;
p->ct = time;
p->bt1 = 0;
n1++;
}
print_input();
sort();
}
}
void print_gantt_chart()
{
int i,j,m;
s1[0] = s[0];
for(i=1,j=0;i<k;i++)
{
if(strcmp(s[i].pname,s1[j].pname)==0)
s1[j].end = s[i].end;
else
s1[++j] = s[i];
}
printf("%d",s1[0].start);
for(i=0;i<=j;i++)
{
m = (s1[i].end - s1[i].start);
for(k=0;k<m/2;k++)
printf("-");
printf("%s",s1[i].pname);
for(k=0;k<(m+1)/2;k++)
printf("-");
printf("%d",s1[i].end);
}
}
int main()
{
accept_info();
sort();
sjfnp();
print_output();
print_gantt_chart();
return 0;
}
Output:
Enter no.of process:4
Enter process name:p1
Enter arrival time:1
Enter first CPU burst time:5
Enter process name:p2
Enter arrival time:0
Enter first CPU burst time:7
Enter process name:p3
Enter arrival time:3
Enter first CPU burst time:3
Enter process name:p4
Enter arrival time:2
Enter first CPU burst time:10
pname at bt
p2 0 0
p1 1 5
p4 2 10
p3 3 3
pname at bt
p2 0 0
p1 1 5
p4 2 10
p3 3 0
pname at bt
p2 0 0
p1 1 0
p4 2 10
p3 3 0
pname at bt
p2 0 0
p1 1 0
p4 2 0
p3 3 0
pname at bt ct tat wt
p2 0 7 7 7 0
p1 1 5 15 14 9
p4 2 10 25 23 13
p3 3 3 10 7 4
Avg TAT=12.750000 Avg WT=6.500000
0---p2----7-p3--10--p1---15-----p4-----25

------------------------------------------------------------------------------------------------------------------------------------------

slip No 15 

2b,10,11,12,15,19 search

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
void make_toks(char *s, char *tok[])
{
int i=0;
char *p;
p = strtok(s," ");
while(p!=NULL)
{
tok[i++]=p;
p=strtok(NULL," ");
}
tok[i]=NULL;
}
void list(char *dn, char op)
{
DIR *dp;
struct dirent *entry;
int dc=0,fc=0;
dp = opendir(dn);
if(dp==NULL)
{
printf("Dir %s not found.\n",dn);
return;
}
switch(op)
{
case 'f':
while(entry=readdir(dp))
{
if(entry->d_type==DT_REG)
printf("%s\n",entry->d_name);
}
break;
case 'n':
while(entry=readdir(dp))
{
if(entry->d_type==DT_DIR)
dc++;
if(entry->d_type==DT_REG)
fc++;
}
printf("%d Dir(s)\t%d File(s)\n",dc,fc);
break;
case 'i':
while(entry=readdir(dp))
{
if(entry->d_type==DT_REG)
printf("%s\t%d\n",entry->d_name,entry->d_fileno);
}
}
closedir(dp);
}
int main()
{
char buff[80],*args[10];
int pid;
while(1)
{
printf("\nmyshell$");
fflush(stdin);
fgets(buff,80,stdin);
buff[strlen(buff)-1]='\0';
make_toks(buff,args);
if(strcmp(args[0],"list")==0)
list(args[2],args[1][0]);
else
{
pid = fork();
if(pid>0)
wait();
else
{
if(execvp(args[0],args)==-1)
printf("Bad command.\n");
}
}
}
Output :
For creating directory type mkdir directory name example mkdir newdir
cd newdir
for creating files in directory type touch text filename.txt example touch test.txt
create multiple file using same way after creating file use vim text filename.txt and write
text in text files .
return to your original directory type cd –
now run your program using ./a.out command
output - myshell$ list f newdir
test.txt
test1.txt
test2.txt
test3.txt
myshell$ list n newdir
2 Dir(s) 4 File(s)
myshell$ list i newdir
test.txt 114949
test1.txt 114945
test2.txt 4271
test3.txt 114947

----------------------------

15 preemptive sjf 


Write the program to simulate Preemptive Shortest Job First (SJF) -scheduling. The arrival
time and first CPU-burst for different n number of processes should be input to the
algorithm. Assume the fixed IO waiting time (2 units). The next CPU-burst should be
generated randomly. The output should give Gantt chart, turnaround time and waiting time
for each process. Also find the average waiting time and turnaround time.
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct process_info
{
char pname[20];
int at,bt,ct,bt1;
struct process_info *next;
}NODE;
int n;
NODE *first,*last;
void accept_info()
{
NODE *p;
int i;
printf("Enter no.of process:");
scanf("%d",&n);
for(i=0;i<n;i++)
{
p = (NODE*)malloc(sizeof(NODE));
printf("Enter process name:");
scanf("%s",p->pname);
printf("Enter arrival time:");
scanf("%d",&p->at);
printf("Enter first CPU burst time:");
scanf("%d",&p->bt);
p->bt1 = p->bt;
p->next = NULL;
if(first==NULL)
first=p;
else
last->next=p;
last = p;
}
}
void print_output()
{
NODE *p;
float avg_tat=0,avg_wt=0;
printf("pname\tat\tbt\tct\ttat\twt\n");
p = first;
while(p!=NULL)
{
int tat = p->ct-p->at;
int wt = tat-p->bt;
avg_tat+=tat;
avg_wt+=wt;
printf("%s\t%d\t%d\t%d\t%d\t%d\n",
p->pname,p->at,p->bt,p->ct,tat,wt);
p=p->next;
}
printf("Avg TAT=%f\tAvg WT=%f\n",
avg_tat/n,avg_wt/n);
}
void print_input()
{
NODE *p;
p = first;
printf("pname\tat\tbt\n");
while(p!=NULL)
{
printf("%s\t%d\t%d\n",
p->pname,p->at,p->bt1);
p = p->next;
}
}
void sort()
{
NODE *p,*q;
int t;
char name[20];
p = first;
while(p->next!=NULL)
{
q=p->next;
while(q!=NULL)
{
if(p->at > q->at)
{
strcpy(name,p->pname);
strcpy(p->pname,q->pname);
strcpy(q->pname,name);
t = p->at;
p->at = q->at;
q->at = t;
t = p->bt;
p->bt = q->bt;
q->bt = t;
t = p->ct;
p->ct = q->ct;
q->ct = t;
t = p->bt1;
p->bt1 = q->bt1;
q->bt1 = t;
}
q=q->next;
}
p=p->next;
}
}
int time;
NODE * get_sjf()
{
NODE *p,*min_p=NULL;
int min=9999;
p = first;
while(p!=NULL)
{
if(p->at<=time && p->bt1!=0 &&
p->bt1<min)
{
min = p->bt1;
min_p = p;
}
p=p->next;
}
return min_p;
}
struct gantt_chart
{
int start;
char pname[30];
int end;
}s[100],s1[100];
int k;
void sjfp()
{
int prev=0,n1=0;
NODE *p;
while(n1!=n)
{
p = get_sjf();
if(p==NULL)
{
time++;
s[k].start = prev;
strcpy(s[k].pname,"*");
s[k].end = time;
prev = time;
k++;
}
else
{
time++;
s[k].start = prev;
strcpy(s[k].pname, p->pname);
s[k].end = time;
prev = time;
k++;
p->ct = time;
p->bt1--;
if(p->bt1==0)
n1++;
}
print_input();
sort();
}
}
void print_gantt_chart()
{
int i,j,m;
s1[0] = s[0];
for(i=1,j=0;i<k;i++)
{
if(strcmp(s[i].pname,s1[j].pname)==0)
s1[j].end = s[i].end;
else
s1[++j] = s[i];
}
printf("%d",s1[0].start);
for(i=0;i<=j;i++)
{
m = (s1[i].end - s1[i].start);
for(k=0;k<m/2;k++)
printf("-");
printf("%s",s1[i].pname);
for(k=0;k<(m+1)/2;k++)
printf("-");
printf("%d",s1[i].end);
}
}
int main()
{
accept_info();
sort();
sjfp();
print_output();
print_gantt_chart();
return 0;
}
Output:
Enter no.of process:4
Enter process name:p1
Enter arrival time:1
Enter first CPU burst time:5
Enter process name:p2
Enter arrival time:0
Enter first CPU burst time:7
Enter process name:p3
Enter arrival time:3
Enter first CPU burst time:3
Enter process name:p3
Enter arrival time:2
Enter first CPU burst time:10
pname at bt
p2 0 6
p1 1 5
p3 2 10
p3 3 3
pname at bt
p2 0 6
p1 1 4
p3 2 10
p3 3 3
pname at bt
p2 0 6
p1 1 3
p3 2 10
p3 3 3
pname at bt
p2 0 6
p1 1 2
p3 2 10
p3 3 3
pname at bt
p2 0 6
p1 1 1
p3 2 10
p3 3 3
pname at bt
p2 0 6
p1 1 0
p3 2 10
p3 3 3
pname at bt
p2 0 6
p1 1 0
p3 2 10
p3 3 2
pname at bt
p2 0 6
p1 1 0
p3 2 10
p3 3 1
pname at bt
p2 0 6
p1 1 0
p3 2 10
p3 3 0
pname at bt
p2 0 5
p1 1 0
p3 2 10
p3 3 0
pname at bt
p2 0 4
p1 1 0
p3 2 10
p3 3 0
pname at bt
p2 0 3
p1 1 0
p3 2 10
p3 3 0
pname at bt
p2 0 2
p1 1 0
p3 2 10
p3 3 0
pname at bt
p2 0 1
p1 1 0
p3 2 10
p3 3 0
pname at bt
p2 0 0
p1 1 0
p3 2 10
p3 3 0
pname at bt
p2 0 0
p1 1 0
p3 2 9
p3 3 0
pname at bt
p2 0 0
p1 1 0
p3 2 8
p3 3 0
pname at bt
p2 0 0
p1 1 0
p3 2 7
p3 3 0
pname at bt
p2 0 0
p1 1 0
p3 2 6
p3 3 0
pname at bt
p2 0 0
p1 1 0
p3 2 5
p3 3 0
pname at bt
p2 0 0
p1 1 0
p3 2 4
p3 3 0
pname at bt
p2 0 0
p1 1 0
p3 2 3
p3 3 0
pname at bt
p2 0 0
p1 1 0
p3 2 2
p3 3 0
pname at bt
p2 0 0
p1 1 0
p3 2 1
p3 3 0
pname at bt
p2 0 0
p1 1 0
p3 2 0
p3 3 0
pname at bt ct tat wt
p2 0 7 15 15 8
p1 1 5 6 5 0
p3 2 10 25 23 13
p3 3 3 9 6 3
Avg TAT=12.250000 Avg WT=6.000000
0p2-1--p1---6-p3--9---p2---15-----p3-----25


------------------------------------------------------------------------------------------------------------------------------------------

slip no 16 

3,16,24 count 

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
void make_toks(char *s, char *tok[])
{
int i=0;
char *p;
p = strtok(s," ");
while(p!=NULL)
{
tok[i++]=p;
p=strtok(NULL," ");
}
tok[i]=NULL;
}
void count(char *fn, char op)
{
int fh,cc=0,wc=0,lc=0;
char c;
fh = open(fn,O_RDONLY);
if(fh==-1)
{
printf("File %s not found.\n",fn);
return;
}
while(read(fh,&c,1)>0)
{
if(c==' ') wc++;
else if(c=='\n')
{
wc++;
lc++;
}
cc++;
}
close(fh);
switch(op)
{
case 'c':
printf("No.of characters:%d\n",cc-1);
break;
case 'w':
printf("No.of words:%d\n",wc);
break;
case 'l':
printf("No.of lines:%d\n",lc+1);
break;
}
}
int main()
{
char buff[80],*args[10];
int pid;
while(1)
{
printf("myshell$ ");
fflush(stdin);
fgets(buff,80,stdin);
buff[strlen(buff)-1]='\0';
make_toks(buff,args);
if(strcmp(args[0],"count")==0)
count(args[2],args[1][0]);
else
{
pid = fork();
if(pid>0)
wait();
else
{
if(execvp(args[0],args)==-1)
printf("Bad command.\n");
}
}
}
return 0;
}
Output :
after compile create text file
for text file type vim textfile name.txt ,example : vim info.txt
press i write text in text file press esc :wq
now run program using ./a.out command
myshell$ count c info.txt
No.of characters:45
myshell$ count w info.txt
No.of words:3
myshell$ count l info.txt
No.of lines:3
myshell$
<---info.txt--->
Hello world
Ramayan-Valmiki
Bhagwatgeeta-Vyasa

-----------------------------------------------

22,16,non preemptive prority  

Write the program to simulate Non-preemptive Priority scheduling. The arrival time and
first CPU-burst and priority for different n number of processes should be input to the
algorithm. Assume the fixed IO waiting time (2 units). The next CPU-burst should be
generated randomly. The output should give Gantt chart, turnaround time and waiting time
for each process. Also find the average waiting time and turnaround time.
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct process_info
{
char pname[20];
int at,bt,ct,bt1,p;
struct process_info *next;
}NODE;
int n;
NODE *first,*last;
void accept_info()
{
NODE *p;
int i;
printf("Enter no.of process:");
scanf("%d",&n);
for(i=0;i<n;i++)
{
p = (NODE*)malloc(sizeof(NODE));
printf("Enter process name:");
scanf("%s",p->pname);
printf("Enter arrival time:");
scanf("%d",&p->at);
printf("Enter first CPU burst time:");
scanf("%d",&p->bt);
printf("Enter priority:");
scanf("%d",&p->p);
p->bt1 = p->bt;
p->next = NULL;
if(first==NULL)
first=p;
else
last->next=p;
last = p;
}
}
void print_output()
{
NODE *p;
float avg_tat=0,avg_wt=0;
printf("pname\tat\tbt\tp\ttct\ttat\twt\n");
p = first;
while(p!=NULL)
{
int tat = p->ct-p->at;
int wt = tat-p->bt;
avg_tat+=tat;
avg_wt+=wt;
printf("%s\t%d\t%d\t%d\t%d\t%d\t%d\n",
p->pname,p->at,p->bt,p->p,p->ct,tat,wt);
p=p->next;
}
printf("Avg TAT=%f\tAvg WT=%f\n",
avg_tat/n,avg_wt/n);
}
void print_input()
{
NODE *p;
p = first;
printf("pname\tat\tbt\tp\n");
while(p!=NULL)
{
printf("%s\t%d\t%d\t%d\n",
p->pname,p->at,p->bt1,p->p);
p = p->next;
}
}
void sort()
{
NODE *p,*q;
int t;
char name[20];
p = first;
while(p->next!=NULL)
{
q=p->next;
while(q!=NULL)
{
if(p->at > q->at)
{
strcpy(name,p->pname);
strcpy(p->pname,q->pname);
strcpy(q->pname,name);
t = p->at;
p->at = q->at;
q->at = t;
t = p->bt;
p->bt = q->bt;
q->bt = t;
t = p->ct;
p->ct = q->ct;
q->ct = t;
t = p->bt1;
p->bt1 = q->bt1;
q->bt1 = t;
t = p->p;
p->p = q->p;
q->p = t;
}
q=q->next;
}
p=p->next;
}
}
int time;
NODE * get_p()
{
NODE *p,*min_p=NULL;
int min=9999;
p = first;
while(p!=NULL)
{
if(p->at<=time && p->bt1!=0 &&
p->p<min)
{
min = p->p;
min_p = p;
}
p=p->next;
}
return min_p;
}
struct gantt_chart
{
int start;
char pname[30];
int end;
}s[100],s1[100];
int k;
void pnp()
{
int prev=0,n1=0;
NODE *p;
while(n1!=n)
{
p = get_p();
if(p==NULL)
{
time++;
s[k].start = prev;
strcpy(s[k].pname,"*");
s[k].end = time;
prev = time;
k++;
}
else
{
time+=p->bt1;
s[k].start = prev;
strcpy(s[k].pname, p->pname);
s[k].end = time;
prev = time;
k++;
p->ct = time;
p->bt1 = 0;
n1++;
}
print_input();
sort();
}
}
void print_gantt_chart()
{
int i,j,m;
s1[0] = s[0];
for(i=1,j=0;i<k;i++)
{
if(strcmp(s[i].pname,s1[j].pname)==0)
s1[j].end = s[i].end;
else
s1[++j] = s[i];
}
printf("%d",s1[0].start);
for(i=0;i<=j;i++)
{
m = (s1[i].end - s1[i].start);
for(k=0;k<m/2;k++)
printf("-");
printf("%s",s1[i].pname);
for(k=0;k<(m+1)/2;k++)
printf("-");
printf("%d",s1[i].end);
}
}
int main()
{
accept_info();
sort();
pnp();
print_output();
print_gantt_chart();
return 0;
}
Output :
Enter no.of process:4
Enter process name:p1
Enter arrival time:0
Enter first CPU burst time:8
Enter priority:4
Enter process name:p2
Enter arrival time:1
Enter first CPU burst time:6
Enter priority:6
Enter process name:p3
Enter arrival time:3
Enter first CPU burst time:7
Enter priority:3
Enter process name:p4
Enter arrival time:3
Enter first CPU burst time:9
Enter priority:1
pname at bt p
p1 0 0 4
p2 1 6 6
p3 3 7 3
p4 3 9 1
pname at bt p
p1 0 0 4
p2 1 6 6
p3 3 7 3
p4 3 0 1
pname at bt p
p1 0 0 4
p2 1 6 6
p3 3 0 3
p4 3 0 1
pname at bt p
p1 0 0 4
p2 1 0 6
p3 3 0 3
p4 3 0 1
pname at bt p tct tat wt
p1 0 8 4 8 8 0
p2 1 6 6 30 29 23
p3 3 7 3 24 21 14
p4 3 9 1 17 14 5
Avg TAT=18.000000 Avg WT=10.500000
0----p1----8----p4-----17---p3----24---p2---30

------------------------------------------------------------------------------------------------------------------------------------------

slip No 17

17,18 fcfs 

Write the program to simulate FCFS CPU-scheduling. The arrival time and first CPUburst for
different n number of processes should be input to the algorithm. Assume that the fixed IO
waiting time (2 units). The next CPU-burst should be generated randomly. The output should
give Gantt chart, turnaround time and waiting time for each process. Also find the average
waiting time and turnaround time.
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct process_info
{
char pname[20];
int at,bt,ct,bt1;
struct process_info *next;
}NODE;
int n;
NODE *first,*last;
void accept_info()
{
NODE *p;
int i;
printf("Enter no.of process:");
scanf("%d",&n);
for(i=0;i<n;i++)
{
p = (NODE*)malloc(sizeof(NODE));
printf("Enter process name:");
scanf("%s",p->pname);
printf("Enter arrival time:");
scanf("%d",&p->at);
printf("Enter first CPU burst time:");
scanf("%d",&p->bt);
p->bt1 = p->bt;
p->next = NULL;
if(first==NULL)
first=p;
else
last->next=p;
last = p;
}
}
void print_output()
{
NODE *p;
float avg_tat=0,avg_wt=0;
printf("pname\tat\tbt\tct\ttat\twt\n");
p = first;
while(p!=NULL)
{
int tat = p->ct-p->at;
int wt = tat-p->bt;
avg_tat+=tat;
avg_wt+=wt;
printf("%s\t%d\t%d\t%d\t%d\t%d\n",
p->pname,p->at,p->bt,p->ct,tat,wt);
p=p->next;
}
printf("Avg TAT=%f\tAvg WT=%f\n",
avg_tat/n,avg_wt/n);
}
void print_input()
{
NODE *p;
p = first;
printf("pname\tat\tbt\n");
while(p!=NULL)
{
printf("%s\t%d\t%d\n",
p->pname,p->at,p->bt1);
p = p->next;
}
}
void sort()
{
NODE *p,*q;
int t;
char name[20];
p = first;
while(p->next!=NULL)
{
q=p->next;
while(q!=NULL)
{
if(p->at > q->at)
{
strcpy(name,p->pname);
strcpy(p->pname,q->pname);
strcpy(q->pname,name);
t = p->at;
p->at = q->at;
q->at = t;
t = p->bt;
p->bt = q->bt;
q->bt = t;
t = p->ct;
p->ct = q->ct;
q->ct = t;
t = p->bt1;
p->bt1 = q->bt1;
q->bt1 = t;
}
q=q->next;
}
p=p->next;
}
}
int time;
NODE * get_fcfs()
{
NODE *p;
p = first;
while(p!=NULL)
{
if(p->at<=time && p->bt1!=0)
return p;
p=p->next;
}
return NULL;
}
struct gantt_chart
{
int start;
char pname[30];
int end;
}s[100],s1[100];
int k;
void fcfs()
{
int prev=0,n1=0;
NODE *p;
while(n1!=n)
{
p = get_fcfs();
if(p==NULL)
{
time++;
s[k].start = prev;
strcpy(s[k].pname,"*");
s[k].end = time;
prev = time;
k++;
}
else
{
time+=p->bt1;
s[k].start = prev;
strcpy(s[k].pname, p->pname);
s[k].end = time;
prev = time;
k++;
p->ct = time;
p->bt1 = 0;
n1++;
}
print_input();
sort();
}
}
void print_gantt_chart()
{
int i,j,m;
s1[0] = s[0];
for(i=1,j=0;i<k;i++)
{
if(strcmp(s[i].pname,s1[j].pname)==0)
s1[j].end = s[i].end;
else
s1[++j] = s[i];
}
printf("%d",s1[0].start);
for(i=0;i<=j;i++)
{
m = (s1[i].end - s1[i].start);
for(k=0;k<m/2;k++)
printf("-");
printf("%s",s1[i].pname);
for(k=0;k<(m+1)/2;k++)
printf("-");
printf("%d",s1[i].end);
}
}
int main()
{
accept_info();
sort();
fcfs();
print_output();
print_gantt_chart();
return 0;
}
Output:
Enter no.of process:5
Enter process name:p1
Enter arrival time:3
Enter first CPU burst time:4
Enter process name:p2
Enter arrival time:5
Enter first CPU burst time:3
Enter process name:p3
Enter arrival time:0
Enter first CPU burst time:2
Enter process name:p4
Enter arrival time:5
Enter first CPU burst time:1
Enter process name:p5
Enter arrival time:4
Enter first CPU burst time:3
pname at bt
p3 0 0
p1 3 4
p5 4 3
p4 5 1
p2 5 3
pname at bt
p3 0 0
p1 3 4
p5 4 3
p4 5 1
p2 5 3
pname at bt
p3 0 0
p1 3 0
p5 4 3
p4 5 1
p2 5 3
pname at bt
p3 0 0
p1 3 0
p5 4 0
p4 5 1
p2 5 3
pname at bt
p3 0 0
p1 3 0
p5 4 0
p4 5 0
p2 5 3
pname at bt
p3 0 0
p1 3 0
p5 4 0
p4 5 0
p2 5 0
pname at bt ct tat wt
p3 0 2 2 2 0
p1 3 4 7 4 0
p5 4 3 10 6 3
p4 5 1 11 6 5
p2 5 3 14 9 6
Avg TAT=5.400000 Avg WT=2.800000
0-p3-2*-3--p1--7-p5--10p4-11-p2—14


------------------------
23,5,7,17 opt 

#include<stdio.h>
int main()
{
int no_of_frames, no_of_pages, frames[10], pages[30], temp[10], flag1, flag2, flag3, i, j, k, pos,
max, faults = 0;
printf("Enter number of frames: ");
scanf("%d", &no_of_frames);
printf("Enter number of pages: ");
scanf("%d", &no_of_pages);
printf("Enter page reference string: ");
for(i = 0; i < no_of_pages; ++i){
scanf("%d", &pages[i]);
}
for(i = 0; i < no_of_frames; ++i){
frames[i] = -1;
}
for(i = 0; i < no_of_pages; ++i){
flag1 = flag2 = 0;
for(j = 0; j < no_of_frames; ++j){
if(frames[j] == pages[i]){
flag1 = flag2 = 1;
break;
}
}
if(flag1 == 0){
for(j = 0; j < no_of_frames; ++j){
if(frames[j] == -1){
faults++;
frames[j] = pages[i];
flag2 = 1;
break;
}
}
}
if(flag2 == 0){
flag3 =0;
for(j = 0; j < no_of_frames; ++j){
temp[j] = -1;
for(k = i + 1; k < no_of_pages; ++k){
if(frames[j] == pages[k]){
temp[j] = k;
break;
}
}
}
for(j = 0; j < no_of_frames; ++j){
if(temp[j] == -1){
pos = j;
flag3 = 1;
break;
}
}
if(flag3 ==0){
max = temp[0];
pos = 0;
for(j = 1; j < no_of_frames; ++j){
if(temp[j] > max){
max = temp[j];
pos = j;
}
}
}
frames[pos] = pages[i];
faults++;
}
printf("\n");
for(j = 0; j < no_of_frames; ++j){
printf("%d\t", frames[j]);
}
}
printf("\n\nTotal Page Faults = %d", faults);
return 0;
}
Output:
./a.out
Enter number of frames: 4
Enter number of pages: 12 15 12 18 6 8 11 12 19 12 6 8 12 15 19 8
Enter page reference string:
15 -1 -1 -1
15 12 -1 -1
15 12 18 -1
15 12 18 6
8 12 18 6
8 12 11 6
8 12 11 6
8 12 19 6
8 12 19 6
8 12 19 6
8 12 19 6
8 12 19 6
Total Page Faults = 7

------------------------------------------------------------------------------------------------------------------------------------------


slip No 18 

3,8,12,18 iru 

#include<stdio.h>
#define MAX 20
int frames[MAX],ref[MAX],mem[MAX][MAX],faults,
sp,m,n,time[MAX];
void accept()
{
int i;
printf("Enter no.of frames:");
scanf("%d", &n);
printf("Enter no.of references:");
scanf("%d", &m);
printf("Enter reference string:\n");
for(i=0;i<m;i++)
{
printf("[%d]=",i);
scanf("%d",&ref[i]);
}
}
void disp()
{
int i,j;
for(i=0;i<m;i++)
printf("%3d",ref[i]);
printf("\n\n");
for(i=0;i<n;i++)
{
for(j=0;j<m;j++)
{
if(mem[i][j])
printf("%3d",mem[i][j]);
else
printf(" ");
}
printf("\n");
}
printf("Total Page Faults: %d\n",faults);
}
int search(int pno)
{
int i;
for(i=0;i<n;i++)
{
if(frames[i]==pno)
return i;
}
return -1;
}
int get_lru()
{
int i,min_i,min=9999;
for(i=0;i<n;i++)
{
if(time[i]<min)
{
min = time[i];
min_i = i;
}
}
return min_i;
}
void lru()
{
int i,j,k;
for(i=0;i<m && sp<n;i++)
{
k=search(ref[i]);
if(k==-1)
{
frames[sp]=ref[i];
time[sp]=i;
faults++;
sp++;
for(j=0;j<n;j++)
mem[j][i]=frames[j];
}
else
time[k]=i;
}
for(;i<m;i++)
{
k = search(ref[i]);
if(k==-1)
{
sp = get_lru();
frames[sp] = ref[i];
time[sp] = i;
faults++;
for(j=0;j<n;j++)
mem[j][i] = frames[j];
}
else
time[k]=i;
}
}
int main()
{
accept();
lru();
disp();
return 0;
}
Output:
Enter no.of frames:4
Enter no.of references:16
Enter reference string:
[0]=12
[1]=15
[2]=12
[3]=18
[4]=6
[5]=8
[6]=11
[7]=12
[8]=19
[9]=12
[10]=6
[11]=8
[12]=12
[13]=15
[14]=19
[15]=8
12 15 12 18 6 8 11 12 19 12 6 8 12 15 19 8
12 12 12 12 12 11 11 11 11 8 8 8
15 15 15 8 8 8 8 6 6 6 19
18 18 18 18 12 12 12 12 12 12
6 6 6 6 19 19 19 15 15
Total Page Faults: 12

--------------------------------------

17,18 fcfs 

Write the program to simulate FCFS CPU-scheduling. The arrival time and first CPUburst for
different n number of processes should be input to the algorithm. Assume that the fixed IO
waiting time (2 units). The next CPU-burst should be generated randomly. The output should
give Gantt chart, turnaround time and waiting time for each process. Also find the average
waiting time and turnaround time.
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct process_info
{
char pname[20];
int at,bt,ct,bt1;
struct process_info *next;
}NODE;
int n;
NODE *first,*last;
void accept_info()
{
NODE *p;
int i;
printf("Enter no.of process:");
scanf("%d",&n);
for(i=0;i<n;i++)
{
p = (NODE*)malloc(sizeof(NODE));
printf("Enter process name:");
scanf("%s",p->pname);
printf("Enter arrival time:");
scanf("%d",&p->at);
printf("Enter first CPU burst time:");
scanf("%d",&p->bt);
p->bt1 = p->bt;
p->next = NULL;
if(first==NULL)
first=p;
else
last->next=p;
last = p;
}
}
void print_output()
{
NODE *p;
float avg_tat=0,avg_wt=0;
printf("pname\tat\tbt\tct\ttat\twt\n");
p = first;
while(p!=NULL)
{
int tat = p->ct-p->at;
int wt = tat-p->bt;
avg_tat+=tat;
avg_wt+=wt;
printf("%s\t%d\t%d\t%d\t%d\t%d\n",
p->pname,p->at,p->bt,p->ct,tat,wt);
p=p->next;
}
printf("Avg TAT=%f\tAvg WT=%f\n",
avg_tat/n,avg_wt/n);
}
void print_input()
{
NODE *p;
p = first;
printf("pname\tat\tbt\n");
while(p!=NULL)
{
printf("%s\t%d\t%d\n",
p->pname,p->at,p->bt1);
p = p->next;
}
}
void sort()
{
NODE *p,*q;
int t;
char name[20];
p = first;
while(p->next!=NULL)
{
q=p->next;
while(q!=NULL)
{
if(p->at > q->at)
{
strcpy(name,p->pname);
strcpy(p->pname,q->pname);
strcpy(q->pname,name);
t = p->at;
p->at = q->at;
q->at = t;
t = p->bt;
p->bt = q->bt;
q->bt = t;
t = p->ct;
p->ct = q->ct;
q->ct = t;
t = p->bt1;
p->bt1 = q->bt1;
q->bt1 = t;
}
q=q->next;
}
p=p->next;
}
}
int time;
NODE * get_fcfs()
{
NODE *p;
p = first;
while(p!=NULL)
{
if(p->at<=time && p->bt1!=0)
return p;
p=p->next;
}
return NULL;
}
struct gantt_chart
{
int start;
char pname[30];
int end;
}s[100],s1[100];
int k;
void fcfs()
{
int prev=0,n1=0;
NODE *p;
while(n1!=n)
{
p = get_fcfs();
if(p==NULL)
{
time++;
s[k].start = prev;
strcpy(s[k].pname,"*");
s[k].end = time;
prev = time;
k++;
}
else
{
time+=p->bt1;
s[k].start = prev;
strcpy(s[k].pname, p->pname);
s[k].end = time;
prev = time;
k++;
p->ct = time;
p->bt1 = 0;
n1++;
}
print_input();
sort();
}
}
void print_gantt_chart()
{
int i,j,m;
s1[0] = s[0];
for(i=1,j=0;i<k;i++)
{
if(strcmp(s[i].pname,s1[j].pname)==0)
s1[j].end = s[i].end;
else
s1[++j] = s[i];
}
printf("%d",s1[0].start);
for(i=0;i<=j;i++)
{
m = (s1[i].end - s1[i].start);
for(k=0;k<m/2;k++)
printf("-");
printf("%s",s1[i].pname);
for(k=0;k<(m+1)/2;k++)
printf("-");
printf("%d",s1[i].end);
}
}
int main()
{
accept_info();
sort();
fcfs();
print_output();
print_gantt_chart();
return 0;
}
Output:
Enter no.of process:5
Enter process name:p1
Enter arrival time:3
Enter first CPU burst time:4
Enter process name:p2
Enter arrival time:5
Enter first CPU burst time:3
Enter process name:p3
Enter arrival time:0
Enter first CPU burst time:2
Enter process name:p4
Enter arrival time:5
Enter first CPU burst time:1
Enter process name:p5
Enter arrival time:4
Enter first CPU burst time:3
pname at bt
p3 0 0
p1 3 4
p5 4 3
p4 5 1
p2 5 3
pname at bt
p3 0 0
p1 3 4
p5 4 3
p4 5 1
p2 5 3
pname at bt
p3 0 0
p1 3 0
p5 4 3
p4 5 1
p2 5 3
pname at bt
p3 0 0
p1 3 0
p5 4 0
p4 5 1
p2 5 3
pname at bt
p3 0 0
p1 3 0
p5 4 0
p4 5 0
p2 5 3
pname at bt
p3 0 0
p1 3 0
p5 4 0
p4 5 0
p2 5 0
pname at bt ct tat wt
p3 0 2 2 2 0
p1 3 4 7 4 0
p5 4 3 10 6 3
p4 5 1 11 6 5
p2 5 3 14 9 6
Avg TAT=5.400000 Avg WT=2.800000
0-p3-2*-3--p1--7-p5--10p4-11-p2—14

------------------------------------------------------------------------------------------------------------------------------------------

slip no 19 

2b,10,11,12,15,19 search dir

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
void make_toks(char *s, char *tok[])
{
int i=0;
char *p;
p = strtok(s," ");
while(p!=NULL)
{
tok[i++]=p;
p=strtok(NULL," ");
}
tok[i]=NULL;
}
void list(char *dn, char op)
{
DIR *dp;
struct dirent *entry;
int dc=0,fc=0;
dp = opendir(dn);
if(dp==NULL)
{
printf("Dir %s not found.\n",dn);
return;
}
switch(op)
{
case 'f':
while(entry=readdir(dp))
{
if(entry->d_type==DT_REG)
printf("%s\n",entry->d_name);
}
break;
case 'n':
while(entry=readdir(dp))
{
if(entry->d_type==DT_DIR)
dc++;
if(entry->d_type==DT_REG)
fc++;
}
printf("%d Dir(s)\t%d File(s)\n",dc,fc);
break;
case 'i':
while(entry=readdir(dp))
{
if(entry->d_type==DT_REG)
printf("%s\t%d\n",entry->d_name,entry->d_fileno);
}
}
closedir(dp);
}
int main()
{
char buff[80],*args[10];
int pid;
while(1)
{
printf("\nmyshell$");
fflush(stdin);
fgets(buff,80,stdin);
buff[strlen(buff)-1]='\0';
make_toks(buff,args);
if(strcmp(args[0],"list")==0)
list(args[2],args[1][0]);
else
{
pid = fork();
if(pid>0)
wait();
else
{
if(execvp(args[0],args)==-1)
printf("Bad command.\n");
}
}
}
Output :
For creating directory type mkdir directory name example mkdir newdir
cd newdir
for creating files in directory type touch text filename.txt example touch test.txt
create multiple file using same way after creating file use vim text filename.txt and write
text in text files .
return to your original directory type cd –
now run your program using ./a.out command
output - myshell$ list f newdir
test.txt
test1.txt
test2.txt
test3.txt
myshell$ list n newdir
2 Dir(s) 4 File(s)
myshell$ list i newdir
test.txt 114949
test1.txt 114945
test2.txt 4271
test3.txt 114947

----------------------------------------------

13,19 round robin 

Write the program to simulate Round Robin (RR) scheduling. The arrival time and first
CPU-burst for different n number of processes should be input to the algorithm. Also
give the time quantum as input. Assume the fixed IO waiting time (2 units). The next
CPU-burst should be generated randomly. The output should give Gantt chart,
turnaround time and waiting time for each process. Also find the average waiting time
and turnaround time.
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct process_info
{
char pname[20];
int at,bt,ct,bt1;
struct process_info *next;
}NODE;
int n,ts;
NODE *first,*last;
void accept_info()
{
NODE *p;
int i;
printf("Enter no.of process:");
scanf("%d",&n);
for(i=0;i<n;i++)
{
p = (NODE*)malloc(sizeof(NODE));
printf("Enter process name:");
scanf("%s",p->pname);
printf("Enter arrival time:");
scanf("%d",&p->at);
printf("Enter first CPU burst time:");
scanf("%d",&p->bt);
p->bt1 = p->bt;
p->next = NULL;
if(first==NULL)
first=p;
else
last->next=p;
last = p;
}
printf("Enter time slice:");
scanf("%d",&ts);
}
void print_output()
{
NODE *p;
float avg_tat=0,avg_wt=0;
printf("pname\tat\tbt\tct\ttat\twt\n");
p = first;
while(p!=NULL)
{
int tat = p->ct-p->at;
int wt = tat-p->bt;
avg_tat+=tat;
avg_wt+=wt;
printf("%s\t%d\t%d\t%d\t%d\t%d\n",
p->pname,p->at,p->bt,p->ct,tat,wt);
p=p->next;
}
printf("Avg TAT=%f\tAvg WT=%f\n",
avg_tat/n,avg_wt/n);
}
void print_input()
{
NODE *p;
p = first;
printf("pname\tat\tbt\n");
while(p!=NULL)
{
printf("%s\t%d\t%d\n",
p->pname,p->at,p->bt1);
p = p->next;
}
}
void sort()
{
NODE *p,*q;
int t;
char name[20];
p = first;
while(p->next!=NULL)
{
q=p->next;
while(q!=NULL)
{
if(p->at > q->at)
{
strcpy(name,p->pname);
strcpy(p->pname,q->pname);
strcpy(q->pname,name);
t = p->at;
p->at = q->at;
q->at = t;
t = p->bt;
p->bt = q->bt;
q->bt = t;
t = p->ct;
p->ct = q->ct;
q->ct = t;
t = p->bt1;
p->bt1 = q->bt1;
q->bt1 = t;
}
q=q->next;
}
p=p->next;
}
}
int time;
int is_arrived()
{
NODE *p;
p = first;
while(p!=NULL)
{
if(p->at<=time && p->bt1!=0)
return 1;
p=p->next;
}
return 0;
}
NODE * delq()
{
NODE *t;
t = first;
first = first->next;
t->next=NULL;
return t;
}
void addq(NODE *t)
{
last->next = t;
last = t;
}
struct gantt_chart
{
int start;
char pname[30];
int end;
}s[100],s1[100];
int k;
void rr()
{
int prev=0,n1=0;
NODE *p;
while(n1!=n)
{
if(!is_arrived())
{
time++;
s[k].start = prev;
strcpy(s[k].pname,"*");
s[k].end = time;
k++;
prev=time;
}
else
{
p = first;
while(1)
{
if(p->at<=time && p->bt1!=0)
break;
p = delq();
addq(p);
p = first;
}
if(p->bt1<=ts)
{
time+=p->bt1;
p->bt1=0;
}
else
{
time+=ts;
p->bt1-=ts;
}
p->ct = time;
s[k].start = prev;
strcpy(s[k].pname,p->pname);
s[k].end = time;
k++;
prev = time;
if(p->bt1==0) n1++;
p = delq();
addq(p);
}
print_input();
}
}
void print_gantt_chart()
{
int i,j,m;
s1[0] = s[0];
for(i=1,j=0;i<k;i++)
{
if(strcmp(s[i].pname,s1[j].pname)==0)
s1[j].end = s[i].end;
else
s1[++j] = s[i];
}
printf("%d",s1[0].start);
for(i=0;i<=j;i++)
{
m = (s1[i].end - s1[i].start);
for(k=0;k<m/2;k++)
printf("-");
printf("%s",s1[i].pname);
for(k=0;k<(m+1)/2;k++)
printf("-");
printf("%d",s1[i].end);
}
}
int main()
{
accept_info();
sort();
rr();
print_output();
print_gantt_chart();
return 0;
}
/tmp/k2Oz1QGNYG.o
Enter no.of process:3
Enter process name:P1
Enter arrival time:1
Enter first CPU burst time:3
Enter process name:P2
Enter arrival time:2
Enter first CPU burst time:2
Enter process name:P3
Enter arrival time:0
Enter first CPU burst time:5
Enter time slice:1
pn at bt
P1 1 3
P2 2 2
P3 0 4
pn at bt
P2 2 2
P3 0 4
P1 1 2
pn at bt
P3 0 4
P1 1 2
P2 2 1
pn at bt
P1 1 2
P2 2 1
P3 0 3
pn at bt
P2 2 1
P3 0 3
P1 1 1
pn at bt
P3 0 3
P1 1 1
P2 2 0
pn at bt
P1 1 1
P2 2 0
P3 0 2
pn at bt
P2 2 0
P3 0 2
P1 1 0
pn at bt
P1 1 0
P2 2 0
P3 0 1
pn at bt
P1 1 0
P2 2 0
P3 0 0
pn at bt ct tat wt
P1 1 3 8 7 4
P2 2 2 6 4 2
P3 0 5 10 10 5
Avg TAT=7.000000 Avg WT=3.666667
0P3-1P1-2P2-3P3-4P1-5P2-6P3-7P1-8-P3-10

------------------------------------------------------------------------------------------------------------------------------------------

slip No 20

1b,13 ,14 ,20 typeLine 

#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <unistd.h>
int make_toks(char *s, char *tok[]) {
int i = 0;
char *p;
p = strtok(s, " ");
while(p != NULL) {
tok[i++] = p;
p = strtok(NULL, " ");
}
tok[i] = NULL;
return i;
}
void typeline(char *op, char *fn) {
int fh,
i,
j,
n;
char c;
fh = open(fn, O_RDONLY);
if(fh == -1) {
printf("File %s not found.\n", fn);
return;
}
if(strcmp(op, "a") == 0) {
while(read(fh, &c, 1) > 0)
printf("%c", c);
close(fh);
return;
}
n = atoi(op);
if(n > 0) {
i = 0;
while(read(fh, &c, 1) > 0) {
printf("%c", c);
if(c == '\n') i++;
if(i == n) break;
}
}
if(n < 0) {
i = 0;
while(read(fh, &c, 1) > 0) {
if(c == '\n') i++;
}
lseek(fh, 0, SEEK_SET);
j = 0;
while(read(fh, &c, 1) > 0) {
if(c == '\n') j++;
if(j == i+n+1) break;
}
while(read(fh, &c, 1) > 0) {
printf("%c", c);
}
}
close(fh);
}
int main() {
char buff[80],
*args[10];
while(1) {
printf ("\n");
printf("\nmyshell$ ");
fgets(buff, 80, stdin);
buff[strlen(buff)-1] = '\0';
int n = make_toks(buff, args);
switch (n) {
case 1:
if(strcmp(args[0], "exit") == 0)
exit(1);
if (!fork())
execlp (args [0], args[0], NULL);
break;
case 2:
if (!fork ())
execlp (args [0], args[0], args[1], NULL);
break;
case 3:
if (strcmp(args[0], "typeline") == 0)
typeline (args[1], args[2]);
else {
if (!fork ())
execlp (args [0], args[0], args[1], args[2], NULL);
}
break;
case 4:
if (!fork ())
execlp (args [0], args [0], args [1], args [2], args [3], NULL);
break;
}
}
return 0;
}
o/p:
create text file after compile for text file type vim text.txt insert data in text file press esc
:wq now run your program using ./a.out
myshell$ typeline a text.txt
pune
kolkata
doremon
mumbai
vadapav
chandigarh
pune
prisonbreak
pogo
misalpav
gogo
pune
\0
myshell$ typeline 3 text.txt
pune
kolkata
doremon
myshell$ typeline -5 text.txt
pogo
misalpav
gogo
pune


------------------------------------------------

14,20 non premtive sjf 

Write the program to simulate Non-preemptive Shortest Job First (SJF) -scheduling. The
arrival time and first CPU-burst for different n number of processes should be input to the
algorithm. Assume the fixed IO waiting time (2 units). The next CPU-burst should be
generated randomly. The output should give Gantt chart, turnaround time and waiting time
for each process. Also find the average waiting time and turnaround time.
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct process_info
{
char pname[20];
int at,bt,ct,bt1;
struct process_info *next;
}NODE;
int n;
NODE *first,*last;
void accept_info()
{
NODE *p;
int i;
printf("Enter no.of process:");
scanf("%d",&n);
for(i=0;i<n;i++)
{
p = (NODE*)malloc(sizeof(NODE));
printf("Enter process name:");
scanf("%s",p->pname);
printf("Enter arrival time:");
scanf("%d",&p->at);
printf("Enter first CPU burst time:");
scanf("%d",&p->bt);
p->bt1 = p->bt;
p->next = NULL;
if(first==NULL)
first=p;
else
last->next=p;
last = p;
}
}
void print_output()
{
NODE *p;
float avg_tat=0,avg_wt=0;
printf("pname\tat\tbt\tct\ttat\twt\n");
p = first;
while(p!=NULL)
{
int tat = p->ct-p->at;
int wt = tat-p->bt;
avg_tat+=tat;
avg_wt+=wt;
printf("%s\t%d\t%d\t%d\t%d\t%d\n",
p->pname,p->at,p->bt,p->ct,tat,wt);
p=p->next;
}
printf("Avg TAT=%f\tAvg WT=%f\n",
avg_tat/n,avg_wt/n);
}
void print_input()
{
NODE *p;
p = first;
printf("pname\tat\tbt\n");
while(p!=NULL)
{
printf("%s\t%d\t%d\n",
p->pname,p->at,p->bt1);
p = p->next;
}
}
void sort()
{
NODE *p,*q;
int t;
char name[20];
p = first;
while(p->next!=NULL)
{
q=p->next;
while(q!=NULL)
{
if(p->at > q->at)
{
strcpy(name,p->pname);
strcpy(p->pname,q->pname);
strcpy(q->pname,name);
t = p->at;
p->at = q->at;
q->at = t;
t = p->bt;
p->bt = q->bt;
q->bt = t;
t = p->ct;
p->ct = q->ct;
q->ct = t;
t = p->bt1;
p->bt1 = q->bt1;
q->bt1 = t;
}
q=q->next;
}
p=p->next;
}
}
int time;
NODE * get_sjf()
{
NODE *p,*min_p=NULL;
int min=9999;
p = first;
while(p!=NULL)
{
if(p->at<=time && p->bt1!=0 &&
p->bt1<min)
{
min = p->bt1;
min_p = p;
}
p=p->next;
}
return min_p;
}
struct gantt_chart
{
int start;
char pname[30];
int end;
}s[100],s1[100];
int k;
void sjfnp()
{
int prev=0,n1=0;
NODE *p;
while(n1!=n)
{
p = get_sjf();
if(p==NULL)
{
time++;
s[k].start = prev;
strcpy(s[k].pname,"*");
s[k].end = time;
prev = time;
k++;
}
else
{
time+=p->bt1;
s[k].start = prev;
strcpy(s[k].pname, p->pname);
s[k].end = time;
prev = time;
k++;
p->ct = time;
p->bt1 = 0;
n1++;
}
print_input();
sort();
}
}
void print_gantt_chart()
{
int i,j,m;
s1[0] = s[0];
for(i=1,j=0;i<k;i++)
{
if(strcmp(s[i].pname,s1[j].pname)==0)
s1[j].end = s[i].end;
else
s1[++j] = s[i];
}
printf("%d",s1[0].start);
for(i=0;i<=j;i++)
{
m = (s1[i].end - s1[i].start);
for(k=0;k<m/2;k++)
printf("-");
printf("%s",s1[i].pname);
for(k=0;k<(m+1)/2;k++)
printf("-");
printf("%d",s1[i].end);
}
}
int main()
{
accept_info();
sort();
sjfnp();
print_output();
print_gantt_chart();
return 0;
}
Output:
Enter no.of process:4
Enter process name:p1
Enter arrival time:1
Enter first CPU burst time:5
Enter process name:p2
Enter arrival time:0
Enter first CPU burst time:7
Enter process name:p3
Enter arrival time:3
Enter first CPU burst time:3
Enter process name:p4
Enter arrival time:2
Enter first CPU burst time:10
pname at bt
p2 0 0
p1 1 5
p4 2 10
p3 3 3
pname at bt
p2 0 0
p1 1 5
p4 2 10
p3 3 0
pname at bt
p2 0 0
p1 1 0
p4 2 10
p3 3 0
pname at bt
p2 0 0
p1 1 0
p4 2 0
p3 3 0
pname at bt ct tat wt
p2 0 7 7 7 0
p1 1 5 15 14 9
p4 2 10 25 23 13
p3 3 3 10 7 4
Avg TAT=12.750000 Avg WT=6.500000
0---p2----7-p3--10--p1---15-----p4-----25

------------------------------------------------------------------------------------------------------------------------------------------


slip no 21 

21 fork 

Implement the C Program to create a child process using fork(), display parent and child process
id. Child process will display the message “I am Child Process” and the parent process should
display “I am Parent Process”.
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
int main()
{
// fork() Create a child process
int pid = fork();
if (pid > 0) {
printf("I am Parent process\n");
printf("ID : %d\n\n", getpid());
}
else if (pid == 0) {
printf("I am Child process\n");
// getpid() will return process id of child process
printf("ID: %d\n", getpid());
}
else {
printf("Failed to create child process");
}
return 0;
}
Output :
./a.out
I am Parent process
ID : 3698
I am Child process
ID: 3699
 
-----------------------------------------------------

21 preemtive priority 

Write the program to simulate Preemptive Priority scheduling. The arrival time and first
CPU-burst and priority for different n number of processes should be input to the
algorithm. Assume the fixed IO waiting time (2 units). The next CPU-burst should be
generated randomly. The output should give Gantt chart, turnaround time and waiting
time for each process. Also find the average waiting time and turnaround time.
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct process_info
{
char pname[20];
int at,bt,ct,bt1,p;
struct process_info *next;
}NODE;
int n;
NODE *first,*last;
void accept_info()
{
NODE *p;
int i;
printf("Enter no.of process:");
scanf("%d",&n);
for(i=0;i<n;i++)
{
p = (NODE*)malloc(sizeof(NODE));
printf("Enter process name:");
scanf("%s",p->pname);
printf("Enter arrival time:");
scanf("%d",&p->at);
printf("Enter first CPU burst time:");
scanf("%d",&p->bt);
printf("Enter priority:");
scanf("%d",&p->p);
p->bt1 = p->bt;
p->next = NULL;
if(first==NULL)
first=p;
else
last->next=p;
last = p;
}
}
void print_output()
{
NODE *p;
float avg_tat=0,avg_wt=0;
printf("pname\tat\tbt\tp\ttct\ttat\twt\n");
p = first;
while(p!=NULL)
{
int tat = p->ct-p->at;
int wt = tat-p->bt;
avg_tat+=tat;
avg_wt+=wt;
printf("%s\t%d\t%d\t%d\t%d\t%d\t%d\n",
p->pname,p->at,p->bt,p->p,p->ct,tat,wt);
p=p->next;
}
printf("Avg TAT=%f\tAvg WT=%f\n",
avg_tat/n,avg_wt/n);
}
void print_input()
{
NODE *p;
p = first;
printf("pname\tat\tbt\tp\n");
while(p!=NULL)
{
printf("%s\t%d\t%d\t%d\n",
p->pname,p->at,p->bt1,p->p);
p = p->next;
}
}
void sort()
{
NODE *p,*q;
int t;
char name[20];
p = first;
while(p->next!=NULL)
{
q=p->next;
while(q!=NULL)
{
if(p->at > q->at)
{
strcpy(name,p->pname);
strcpy(p->pname,q->pname);
strcpy(q->pname,name);
t = p->at;
p->at = q->at;
q->at = t;
t = p->bt;
p->bt = q->bt;
q->bt = t;
t = p->ct;
p->ct = q->ct;
q->ct = t;
t = p->bt1;
p->bt1 = q->bt1;
q->bt1 = t;
t = p->p;
p->p = q->p;
q->p = t;
}
q=q->next;
}
p=p->next;
}
}
int time;
NODE * get_p()
{
NODE *p,*min_p=NULL;
int min=9999;
p = first;
while(p!=NULL)
{
if(p->at<=time && p->bt1!=0 &&
p->p<min)
{
min = p->p;
min_p = p;
}
p=p->next;
}
return min_p;
}
struct gantt_chart
{
int start;
char pname[30];
int end;
}s[100],s1[100];
int k;
void pnp()
{
int prev=0,n1=0;
NODE *p;
while(n1!=n)
{
p = get_p();
if(p==NULL)
{
time++;
s[k].start = prev;
strcpy(s[k].pname,"*");
s[k].end = time;
prev = time;
k++;
}
else
{
time++;
s[k].start = prev;
strcpy(s[k].pname, p->pname);
s[k].end = time;
prev = time;
k++;
p->ct = time;
p->bt1--;
if(p->bt1==0) n1++;
}
print_input();
sort();
}
}
void print_gantt_chart()
{
int i,j,m;
s1[0] = s[0];
for(i=1,j=0;i<k;i++)
{
if(strcmp(s[i].pname,s1[j].pname)==0)
s1[j].end = s[i].end;
else
s1[++j] = s[i];
}
printf("%d",s1[0].start);
for(i=0;i<=j;i++)
{
m = (s1[i].end - s1[i].start);
for(k=0;k<m/2;k++)
printf("-");
printf("%s",s1[i].pname);
for(k=0;k<(m+1)/2;k++)
printf("-");
printf("%d",s1[i].end);
}
}
int main()
{
accept_info();
sort();
pnp();
print_output();
print_gantt_chart();
return 0;
}
Output:
Enter no.of process:4
Enter process name:A
Enter arrival time:2
Enter first CPU burst time:3
Enter priority:4
Enter process name:B
Enter arrival time:0
Enter first CPU burst time:3
Enter priority:2
Enter process name:C
Enter arrival time:4
Enter first CPU burst time:6
Enter priority:1
Enter process name:D
Enter arrival time:1
Enter first CPU burst time:4
Enter priority:3
pn at bt p
B 0 2 2
D 1 4 3
A 2 3 4
C 4 6 1
pn at bt p
B 0 1 2
D 1 4 3
A 2 3 4
C 4 6 1
pn at bt p
B 0 0 2
D 1 4 3
A 2 3 4
C 4 6 1
pn at bt p
B 0 0 2
D 1 3 3
A 2 3 4
C 4 6 1
pn at bt p
B 0 0 2
D 1 3 3
A 2 3 4
C 4 5 1
pn at bt p
B 0 0 2
D 1 3 3
A 2 3 4
C 4 4 1
pn at bt p
B 0 0 2
D 1 3 3
A 2 3 4
C 4 3 1
pn at bt p
B 0 0 2
D 1 3 3
A 2 3 4
C 4 2 1
pn at bt p
B 0 0 2
D 1 3 3
A 2 3 4
C 4 1 1
pn at bt p
B 0 0 2
D 1 3 3
A 2 3 4
C 4 0 1
pn at bt p
B 0 0 2
D 1 2 3
A 2 3 4
C 4 0 1
pn at bt p
B 0 0 2
D 1 1 3
A 2 3 4
C 4 0 1
pn at bt p
B 0 0 2
D 1 0 3
A 2 3 4
C 4 0 1
pn at bt p
B 0 0 2
D 1 0 3
A 2 2 4
C 4 0 1
pn at bt p
B 0 0 2
D 1 0 3
A 2 1 4
C 4 0 1
pn at bt p
B 0 0 2
D 1 0 3
A 2 0 4
C 4 0 1
pn at bt p tct tat wt
B 0 3 2 3 3 0
D 1 4 3 13 12 8
A 2 3 4 16 14 11
C 4 6 1 10 6 0
Avg TAT=8.750000 Avg WT=4.750000
0-B--3D-4---C---10-D--13-A—16

------------------------------------------------------------------------------------------------------------------------------------------

Slip No 22 

22 nice 

Write a program that demonstrates the use of nice() system call. After a child process is started
using fork(), assign higher priority to the child using nice() system call.
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
int main()
{
pid_t pid;
pid = fork();
if (pid == 0)
{
printf("\nI am child process, id=%d\n",getpid());
printf("\nPriority :%d,id=%d\n",nice (-7),getpid());
}
else
{
printf("\nI am parent process, id=%d\n",getpid());
nice(1);
printf("\nPriority :%d,id=%d\n",nice (15),getpid());
}
return 0;
}
Output :
I am parent process, id=6555
Priority :6,id=6555
I am child process, id=6556
Priority :-17,id=6556

------------------------------------------------

22,16 non preemptive prority 

Write the program to simulate Non-preemptive Priority scheduling. The arrival time and
first CPU-burst and priority for different n number of processes should be input to the
algorithm. Assume the fixed IO waiting time (2 units). The next CPU-burst should be
generated randomly. The output should give Gantt chart, turnaround time and waiting time
for each process. Also find the average waiting time and turnaround time.
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct process_info
{
char pname[20];
int at,bt,ct,bt1,p;
struct process_info *next;
}NODE;
int n;
NODE *first,*last;
void accept_info()
{
NODE *p;
int i;
printf("Enter no.of process:");
scanf("%d",&n);
for(i=0;i<n;i++)
{
p = (NODE*)malloc(sizeof(NODE));
printf("Enter process name:");
scanf("%s",p->pname);
printf("Enter arrival time:");
scanf("%d",&p->at);
printf("Enter first CPU burst time:");
scanf("%d",&p->bt);
printf("Enter priority:");
scanf("%d",&p->p);
p->bt1 = p->bt;
p->next = NULL;
if(first==NULL)
first=p;
else
last->next=p;
last = p;
}
}
void print_output()
{
NODE *p;
float avg_tat=0,avg_wt=0;
printf("pname\tat\tbt\tp\ttct\ttat\twt\n");
p = first;
while(p!=NULL)
{
int tat = p->ct-p->at;
int wt = tat-p->bt;
avg_tat+=tat;
avg_wt+=wt;
printf("%s\t%d\t%d\t%d\t%d\t%d\t%d\n",
p->pname,p->at,p->bt,p->p,p->ct,tat,wt);
p=p->next;
}
printf("Avg TAT=%f\tAvg WT=%f\n",
avg_tat/n,avg_wt/n);
}
void print_input()
{
NODE *p;
p = first;
printf("pname\tat\tbt\tp\n");
while(p!=NULL)
{
printf("%s\t%d\t%d\t%d\n",
p->pname,p->at,p->bt1,p->p);
p = p->next;
}
}
void sort()
{
NODE *p,*q;
int t;
char name[20];
p = first;
while(p->next!=NULL)
{
q=p->next;
while(q!=NULL)
{
if(p->at > q->at)
{
strcpy(name,p->pname);
strcpy(p->pname,q->pname);
strcpy(q->pname,name);
t = p->at;
p->at = q->at;
q->at = t;
t = p->bt;
p->bt = q->bt;
q->bt = t;
t = p->ct;
p->ct = q->ct;
q->ct = t;
t = p->bt1;
p->bt1 = q->bt1;
q->bt1 = t;
t = p->p;
p->p = q->p;
q->p = t;
}
q=q->next;
}
p=p->next;
}
}
int time;
NODE * get_p()
{
NODE *p,*min_p=NULL;
int min=9999;
p = first;
while(p!=NULL)
{
if(p->at<=time && p->bt1!=0 &&
p->p<min)
{
min = p->p;
min_p = p;
}
p=p->next;
}
return min_p;
}
struct gantt_chart
{
int start;
char pname[30];
int end;
}s[100],s1[100];
int k;
void pnp()
{
int prev=0,n1=0;
NODE *p;
while(n1!=n)
{
p = get_p();
if(p==NULL)
{
time++;
s[k].start = prev;
strcpy(s[k].pname,"*");
s[k].end = time;
prev = time;
k++;
}
else
{
time+=p->bt1;
s[k].start = prev;
strcpy(s[k].pname, p->pname);
s[k].end = time;
prev = time;
k++;
p->ct = time;
p->bt1 = 0;
n1++;
}
print_input();
sort();
}
}
void print_gantt_chart()
{
int i,j,m;
s1[0] = s[0];
for(i=1,j=0;i<k;i++)
{
if(strcmp(s[i].pname,s1[j].pname)==0)
s1[j].end = s[i].end;
else
s1[++j] = s[i];
}
printf("%d",s1[0].start);
for(i=0;i<=j;i++)
{
m = (s1[i].end - s1[i].start);
for(k=0;k<m/2;k++)
printf("-");
printf("%s",s1[i].pname);
for(k=0;k<(m+1)/2;k++)
printf("-");
printf("%d",s1[i].end);
}
}
int main()
{
accept_info();
sort();
pnp();
print_output();
print_gantt_chart();
return 0;
}
Output :
Enter no.of process:4
Enter process name:p1
Enter arrival time:0
Enter first CPU burst time:8
Enter priority:4
Enter process name:p2
Enter arrival time:1
Enter first CPU burst time:6
Enter priority:6
Enter process name:p3
Enter arrival time:3
Enter first CPU burst time:7
Enter priority:3
Enter process name:p4
Enter arrival time:3
Enter first CPU burst time:9
Enter priority:1
pname at bt p
p1 0 0 4
p2 1 6 6
p3 3 7 3
p4 3 9 1
pname at bt p
p1 0 0 4
p2 1 6 6
p3 3 7 3
p4 3 0 1
pname at bt p
p1 0 0 4
p2 1 6 6
p3 3 0 3
p4 3 0 1
pname at bt p
p1 0 0 4
p2 1 0 6
p3 3 0 3
p4 3 0 1
pname at bt p tct tat wt
p1 0 8 4 8 8 0
p2 1 6 6 30 29 23
p3 3 7 3 24 21 14
p4 3 9 1 17 14 5
Avg TAT=18.000000 Avg WT=10.500000
0----p1----8----p4-----17---p3----24---p2---30

------------------------------------------------------------------------------------------------------------------------------------------

Slip No 23

23 orphan 

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
int main()
{
int pid;
pid=getpid();
printf("Current Process ID is : %d\n",pid);
printf("\n[Forking Child Process ... ] \n");
pid=fork();
if(pid < 0)
{
printf("\nProcess can not be created ");
}
else
{
if(pid==0)
{
printf("\nChild Process is Sleeping ...");
sleep(5);
printf("\nOrphan Child's Parent ID : %d",getppid());
}
else
{ /* Parent Process */
printf("\nParent Process Completed ...");
}
}
return 0;
}
Output :
./a.out
Current Process ID is : 5546
[Forking Child Process ... ]
Parent Process Completed ...
Child Process is Sleeping ..

--------------------------------------------

23,5,7,17 opt  

#include<stdio.h>
int main()
{
int no_of_frames, no_of_pages, frames[10], pages[30], temp[10], flag1, flag2, flag3, i, j, k, pos,
max, faults = 0;
printf("Enter number of frames: ");
scanf("%d", &no_of_frames);
printf("Enter number of pages: ");
scanf("%d", &no_of_pages);
printf("Enter page reference string: ");
for(i = 0; i < no_of_pages; ++i){
scanf("%d", &pages[i]);
}
for(i = 0; i < no_of_frames; ++i){
frames[i] = -1;
}
for(i = 0; i < no_of_pages; ++i){
flag1 = flag2 = 0;
for(j = 0; j < no_of_frames; ++j){
if(frames[j] == pages[i]){
flag1 = flag2 = 1;
break;
}
}
if(flag1 == 0){
for(j = 0; j < no_of_frames; ++j){
if(frames[j] == -1){
faults++;
frames[j] = pages[i];
flag2 = 1;
break;
}
}
}
if(flag2 == 0){
flag3 =0;
for(j = 0; j < no_of_frames; ++j){
temp[j] = -1;
for(k = i + 1; k < no_of_pages; ++k){
if(frames[j] == pages[k]){
temp[j] = k;
break;
}
}
}
for(j = 0; j < no_of_frames; ++j){
if(temp[j] == -1){
pos = j;
flag3 = 1;
break;
}
}
if(flag3 ==0){
max = temp[0];
pos = 0;
for(j = 1; j < no_of_frames; ++j){
if(temp[j] > max){
max = temp[j];
pos = j;
}
}
}
frames[pos] = pages[i];
faults++;
}
printf("\n");
for(j = 0; j < no_of_frames; ++j){
printf("%d\t", frames[j]);
}
}
printf("\n\nTotal Page Faults = %d", faults);
return 0;
}
Output:
./a.out
Enter number of frames: 4
Enter number of pages: 12 15 12 18 6 8 11 12 19 12 6 8 12 15 19 8
Enter page reference string:
15 -1 -1 -1
15 12 -1 -1
15 12 18 -1
15 12 18 6
8 12 18 6
8 12 11 6
8 12 11 6
8 12 19 6
8 12 19 6
8 12 19 6
8 12 19 6
8 12 19 6
Total Page Faults = 7

------------------------------------------------------------------------------------------------------------------------------------------


slip No 24 

3,16,24, count 

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
void make_toks(char *s, char *tok[])
{
int i=0;
char *p;
p = strtok(s," ");
while(p!=NULL)
{
tok[i++]=p;
p=strtok(NULL," ");
}
tok[i]=NULL;
}
void count(char *fn, char op)
{
int fh,cc=0,wc=0,lc=0;
char c;
fh = open(fn,O_RDONLY);
if(fh==-1)
{
printf("File %s not found.\n",fn);
return;
}
while(read(fh,&c,1)>0)
{
if(c==' ') wc++;
else if(c=='\n')
{
wc++;
lc++;
}
cc++;
}
close(fh);
switch(op)
{
case 'c':
printf("No.of characters:%d\n",cc-1);
break;
case 'w':
printf("No.of words:%d\n",wc);
break;
case 'l':
printf("No.of lines:%d\n",lc+1);
break;
}
}
int main()
{
char buff[80],*args[10];
int pid;
while(1)
{
printf("myshell$ ");
fflush(stdin);
fgets(buff,80,stdin);
buff[strlen(buff)-1]='\0';
make_toks(buff,args);
if(strcmp(args[0],"count")==0)
count(args[2],args[1][0]);
else
{
pid = fork();
if(pid>0)
wait();
else
{
if(execvp(args[0],args)==-1)
printf("Bad command.\n");
}
}
}
return 0;
}
Output :
after compile create text file
for text file type vim textfile name.txt ,example : vim info.txt
press i write text in text file press esc :wq
now run program using ./a.out command
myshell$ count c info.txt
No.of characters:45
myshell$ count w info.txt
No.of words:3
myshell$ count l info.txt
No.of lines:3
myshell$
<---info.txt--->
Hello world
Ramayan-Valmiki
Bhagwatgeeta-Vyasa

--------------------------------------------------

24 bubble sort 


#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>
void bubblesort(int arr[30],int n)
{
int i,j,temp;
for(i=0;i<n;i++)
{
for(j=0;j<n-1;j++)
{
if(arr[j]>arr[j+1])
{
temp=arr[j];
arr[j]=arr[j+1];
arr[j+1]=temp;
}
}
}
}
void insertionsort(int arr[30], int n)
{
int i, j, temp;
for (i = 1; i < n; i++) {
temp = arr[i];
j = i - 1;
while(j>=0 && temp <= arr[j])
{
arr[j+1] = arr[j];
j = j-1;
}
arr[j+1] = temp;
}
}
void fork1()
{
int arr[25],arr1[25],n,i,status;
printf("\nEnter the no of values in array :");
scanf("%d",&n);
printf("\nEnter the array elements :");
for(i=0;i<n;i++)
scanf("%d",&arr[i]);
int pid=fork();
if(pid==0)
{
sleep(10);
printf("\nchild process\n");
printf("child process id=%d\n",getpid());
insertionsort(arr,n);
printf("\nElements Sorted Using insertionsort:");
printf("\n");
for(i=0;i<n;i++)
printf("%d,",arr[i]);
printf("\b");
printf("\nparent process id=%d\n",getppid());
system("ps -x");
}
else
{
printf("\nparent process\n");
printf("\nparent process id=%d\n",getppid());
bubblesort(arr,n);
printf("Elements Sorted Using bubblesort:");
printf("\n");
for(i=0;i<n;i++)
printf("%d,",arr[i]);
printf("\n\n\n");
}
}
int main()
{
fork1();
return 0;
}
Output:
./a.out
Enter the no of values in array :5
Enter the array elements :2 3 4 1 6
parent process
parent process id=3610
Elements Sorted Using bubblesort:
1,2,3,4,6,








 


